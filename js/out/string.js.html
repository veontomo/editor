<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: string.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: string.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global  DOMParser, Node, Helper, Attributes, Style, Cell, TableRowStyle, Row, ListItem, Table,
          Content, Tag, List, Link, LinkStyle, LinkAttributes */


/**
 * These are methods to convert strings into different objects.
 * @module  Helper
 * @class  StringHelper
 * @version  0.0.2
 * @author A.Shcherbakov
 */
String.prototype.createCellFromHtml = function(){
    /**
     * Transforms a cell-html string into Cell object. It is supposed that the string to process is of the
     * following form: `&lt;td ... > ... &lt;/td>`. Inside the tag, there might be other nodes. If they are recognized
     * as a "supported" ones, the corresponding functions will be called to transform them into objects.
     * @method  createCellFromHtml
     * @return  {Cell|null}
     */
    var htmlStr = this,
        parser = new DOMParser(),
        fullTable = '&lt;table>&lt;tbody>&lt;tr>' + htmlStr + '&lt;/tr>&lt;/tbody>&lt;/table>',
        doc = parser.parseFromString(fullTable, 'text/html'),
        node = doc.getElementsByTagName('td'),
        cell, attrs, nodeStyle, cellContent;
    if (node.length === 0){
        return null;
    }
    // process the first cell in the list of cells. The remaining cells are to be processed
    // at their turn (when the cell becomes first)
    node = node[0];

    // creating object
    cell = new Cell();

    // imposing its styles
    nodeStyle = node.getAttribute('style');
    cell.style = new Style(nodeStyle);

    // imposing its attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty('style')){
        delete attrs.style;
    }
    cell.attr = new Attributes(attrs);

    cellContent = node.innerHTML.inflate();
    cell.content = cellContent;
    return cell;
};

String.prototype.createRowFromHtml = function(){
    /**
     * Transforms a row-html string into a Row object. It is supposed that the string to process is of the
     * following form: &lt;tr ... > ... &lt;/tr>. Inside the tag, there might be elements "td" that will be
     * processed one by one by function String::createCellFromHtml().
     * @method  createRowFromHtml
     * @return  {Object} Row
     */
	var htmlStr = this,
		parser = new DOMParser(),
		fullTable  = '&lt;table>&lt;tbody>' + htmlStr + '&lt;/tbody>&lt;/table>',
		doc = parser.parseFromString(fullTable, 'text/html'),
		node = doc.getElementsByTagName('tr'),
        row = new Row(),
		attrs, i, nodeStyle, cellsNum, currentCell,
        // row = new Row(),
        cell, cells;
	if (node.length === 0){
		return null;
	}
	// the first table row is to be processed. The remaining ones will be processed at thier turn.
	node = node[0];

	// imposing styles
	nodeStyle = node.getAttribute('style');
	row.style = new Style(nodeStyle);

	// imposing its attributes
	attrs = Helper.flatten(node.attributes);
	if (attrs.hasOwnProperty('style')){
		delete attrs.style;
	}
	row.attr = new Attributes(attrs);

	cells = node.children;
	cellsNum = cells.length;
	for (i = 0; i &lt; cellsNum; i++){
		currentCell = cells[i];
		if(currentCell.tagName === "TD"){
			cell = currentCell.outerHTML.createCellFromHtml();
			row.appendCell(cell);
		}
	}
	return row;
};

String.prototype.createTableFromHtml = function(){
    /**
     * Creates an object representation from a string that is an html repersentation of a table.
     * Only one table is supposed to be processed at a time, so the string to be processed is to
     * be of the following form `&lt;table ...> ... &lt;/table>`. Inside the tag, there should be tags "tr"
     * that will be processed one by one by function String::createRowFromHtml().
     * @method  createTableFromHtml
     * @return  {Table|null}
     */
    var htmlStr = this,
        parser = new DOMParser(),
        doc = parser.parseFromString(htmlStr, 'text/html'),
        node = doc.getElementsByTagName('table'),
        table, attrs, i, nodeStyle, rows, rowsNum, currentRow, row;
    if (node.length === 0){
        return null;
    }
    node = node[0];

    // creating table
    table = new Table();

    // imposing table styles
    nodeStyle = node.getAttribute('style');
    table.style = new Style(nodeStyle);
    // imposing table attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty('style')){
        delete attrs.style;
    }
    table.attr = new Attributes(attrs);

    // the only child of the table is always tbody
    if (node.children.length !== 1){
        return table;
    }
    rows = node.children[0].children;
    rowsNum = rows.length;

    for (i = 0; i &lt; rowsNum; i++){
        currentRow = rows[i];
        if(currentRow.tagName === "TR"){
            row = currentRow.outerHTML.createRowFromHtml();
            table.appendRow(row);
        }
    }
    // if the table turns out to be framed, "disentanlement" will pull out properties of
    // bogus cells, rows and tables
    table.disentangle();
    return table;
};

String.prototype.createListFromHtml = function(listType){
    /**
     * Transforms a list string into a List object. The argument listType is used to initialize the
     * property "name" of the returned instance. If it is not provided, that the node tag-name property is used.
     * It is supposed that the string to process is of the following form:
     * `&lt;ol ... > ... &lt;/ol>` or `&lt;ul ... > ... &lt;/ul>`.
     * Inside the tag, there might be other nodes. If they are recognized as a "supported" ones, the
     * corresponding functions will be called to transform them into objects.
     * @method   createListFromHtml
     * @param    {String}           listType: ul or li
     * @return   {List|null}
     */
    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, 'fakeId'),
        doc = parser.parseFromString('&lt;div id="' + id + '">' + str + '&lt;/div>', 'text/html'),
        output = new List(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        nodeHtml, methodName, methodExists;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        output.name = listType || node.nodeName.toLowerCase();

        style = node.getAttribute('style');
        output.style = new Style(style);
        attrs = Helper.flatten(node.attributes);
        if (attrs.hasOwnProperty('style')){
            delete attrs.style;
        }
        output.attr = new Attributes(attrs);
        // split the target string on blocks
        children = node.childNodes;
        childrenLen = children.length;
        for(i = 0; i &lt; childrenLen; i++){
            nodeInternal = children[i];
            // parsing only list item nodes
            if (nodeInternal.nodeType === Node.ELEMENT_NODE &amp;&amp; nodeInternal.nodeName === 'LI'){
               nodeHtml = nodeInternal.outerHTML;
               methodName = 'createListItemFromHtml';
               methodExists = (typeof nodeHtml[methodName]) === 'function';
               elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
               output.appendElem(elem);
            }
        }
    }
    return output;
};

String.prototype.createUlFromHtml = function(){
    /**
     * Calls String::createListFromHtml('ul') on the target string.
     * @method  createUlFromHtml
     * @return  {List|null}
     */

    return this.toString().createListFromHtml('ul');
};

String.prototype.createOlFromHtml = function(){
    /**
     * Calls String::createListFromHtml('ol') on the target string.
     * @method  createOlFromHtml
     * @return  {List|null}
     */
    return this.toString().createListFromHtml('ol');
};

String.prototype.createListItemFromHtml = function(){
    /**
     * Transforms a list item string into a ListItem object. It is supposed that the string to process is of the
     * following form: `&lt;li ... > ... &lt;/li>`. Inside the tag, there might be other nodes. If they are recognized
     * as a "supported" ones, the corresponding functions will be called to transform them into objects.
     * @method  createListItemFromHtml
     * @return  {ListItem|null}
     */
    var htmlStr = this,
        parser = new DOMParser(),
        doc = parser.parseFromString('&lt;ul>' + htmlStr + '&lt;/ul>', 'text/html'),
        node = doc.getElementsByTagName('li'),
        listItem, attrs, i, nodeStyle, elem, elems, elemsNum, currentElem, methodToCall, methodExists, nodeName;
    if (node.length === 0){
        return null;
    }
    // process the first element among the found ones. The remaining elements
    // are to be processed at their turn (when each of the becomes first)
    node = node[0];

    // creating object
    listItem = new ListItem();

    // imposing its styles
    nodeStyle = node.getAttribute('style');
    listItem.style = new Style(nodeStyle);

    // imposing its attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty('style')){
        delete attrs.style;
    }
    listItem.attr = new Attributes(attrs);
    elems = node.childNodes;
    elemsNum = elems.length;
    for (i = 0; i &lt; elemsNum; i++){
        currentElem = elems[i];
        switch (currentElem.nodeType){
            case Node.TEXT_NODE:
                elem = currentElem.textContent;
                break;
            case Node.ELEMENT_NODE:
                nodeName = currentElem.nodeName;
                methodToCall = 'create' + Helper.onlyFirstLetterUpperCase(nodeName) + 'FromHtml';
                methodExists = String.prototype.hasOwnProperty(methodToCall);
                elem = methodExists ? currentElem.outerHTML[methodToCall]() : currentElem.outerHTML.createTagFromHtml();
                // console.log('inside ListItem: methodToCall: ', methodToCall, ' methodExists: ', methodExists);
                break;
            default:
                elem = currentElem.nodeValue;
        }
        listItem.appendElem(elem);
    }
    return listItem;
};

String.prototype.createTagFromHtml = function(){
    /**
     * Creates an instance of Tag class and fills in its property "elements" with
     * the elements recognized inside the string. It is supposed that the string is of the
     * form `&lt;tag [tag-attributes] [style="..."]>....&lt;/tag>`.
     * @method    createTagFromHtml
     * @return    {Content|null}
     */

    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, 'fakeId'),
        doc = parser.parseFromString('&lt;div id="' + id + '">' + str + '&lt;/div>', 'text/html'),
        output = new Tag(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        tagName, nodeHtml, methodName, methodExists;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        if (node.nodeType === Node.ELEMENT_NODE){
            tagName = node.nodeName;
            output.name = tagName.toLowerCase();

            style = node.getAttribute('style');
            output.style = new Style(style);
            attrs = Helper.flatten(node.attributes);
            if (attrs.hasOwnProperty('style')){
                delete attrs.style;
            }
            output.attr = new Attributes(attrs);
            // split the target string on blocks
            children = node.childNodes;
            childrenLen = children.length;
            for(i = 0; i &lt; childrenLen; i++){
                nodeInternal = children[i];
                if (nodeInternal.nodeType === Node.TEXT_NODE){
                    elem = nodeInternal.textContent;
                }
                if (nodeInternal.nodeType === Node.ELEMENT_NODE){
                    nodeHtml = nodeInternal.outerHTML;
                    // console.log(nodeInternal.nodeName);
                    methodName = 'create' + Helper.onlyFirstLetterUpperCase(nodeInternal.nodeName) + 'FromHtml';
                    methodExists = (typeof nodeHtml[methodName]) === 'function';
                    elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
                }
                output.appendElem(elem);
            }
        }
    }
    return output;
};
String.prototype.createAFromHtml = function(){
    return this.toString().createLinkFromHtml();
};

String.prototype.createLinkFromHtml = function(){
    /**
     * Creates an instance of Link class and fills in its property "elements" with
     * the elements recognized inside the string. It is supposed that the string is of the
     * form `&lt;tag [tag-attributes] [style="..."]>....&lt;/tag>`.
     * @method    createLinkFromHtml
     * @return    {Link|null}
     */

    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, 'fakeId'),
        doc = parser.parseFromString('&lt;div id="' + id + '">' + str + '&lt;/div>', 'text/html'),
        output = new Link(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        tagName, nodeHtml, methodName, methodExists, href;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        if (node.nodeType === Node.ELEMENT_NODE){
            tagName = node.nodeName;
            output.name = tagName.toLowerCase();

            style = node.getAttribute('style');
            href = node.getAttribute('href');
            output.style = new LinkStyle(style);
            attrs = Helper.flatten(node.attributes);
            if (attrs.hasOwnProperty('style')){
                delete attrs.style;
            }
            output.attr = new LinkAttributes(attrs);
            output.attr.setHref(href);
            // split the target string on blocks
            children = node.childNodes;
            childrenLen = children.length;
            for(i = 0; i &lt; childrenLen; i++){
                nodeInternal = children[i];
                if (nodeInternal.nodeType === Node.TEXT_NODE){
                    elem = nodeInternal.textContent;
                }
                if (nodeInternal.nodeType === Node.ELEMENT_NODE){
                    nodeHtml = nodeInternal.outerHTML;
                    methodName = 'create' + Helper.onlyFirstLetterUpperCase(nodeInternal.nodeName) + 'FromHtml';
                    methodExists = (typeof nodeHtml[methodName]) === 'function';
                    elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
                }
                output.appendElem(elem);
            }
        }
    }
    return output;
};


String.prototype.inflate = function(){
    /*
     * Creates an instance of Content class and fills in its property "elements" with
     * the elements recognized inside the string.
     * @method    inflate
     * @return    {Content}
     */
    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, 'fakeId'),
        doc = parser.parseFromString('&lt;div id="' + id + '">' + str + '&lt;/div>', 'text/html'),
        output = new Content(),
        node, children, childrenNum, i, child, childHtml, elem, methodName, methodExists;
    // generate a unique id for the overall document
    node = doc.getElementById(id);
    children = node.childNodes;
    childrenNum = children.length;
    if (childrenNum > 0){
        for (i = 0; i &lt; childrenNum; i++){
            child = children[i];
            switch (child.nodeType){
                case Node.TEXT_NODE:
                    elem = child.textContent.trim();
                    break;
                case Node.ELEMENT_NODE:
                    childHtml = child.outerHTML;
                    methodName = 'create' + Helper.onlyFirstLetterUpperCase(child.nodeName) + 'FromHtml';
                    methodExists = (typeof childHtml[methodName] === 'function');
                    // if the method exists, apply it to the string representation of
                    // the current node. Otherwise, apply recursively the method "inflate"
                    // to the inner part of the current node.
                    if (methodExists){
                        elem = childHtml[methodName]();
                    } else {
                        elem = childHtml.createTagFromHtml();
                    }
                    break;
                default:
                    elem = child.nodeValue;
            }
            if(elem){
                output.appendElem(elem);
            }

        }
    }
    return output;
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Attributes.html">Attributes</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CKHelper.html">CKHelper</a></li><li><a href="Content.html">Content</a></li><li><a href="Helper.html">Helper</a></li><li><a href="ImageStyle.html">ImageStyle</a></li><li><a href="Link.html">Link</a></li><li><a href="LinkAttributes.html">LinkAttributes</a></li><li><a href="LinkStyle.html">LinkStyle</a></li><li><a href="List.html">List</a></li><li><a href="ListItem.html">ListItem</a></li><li><a href="ListItemStyle.html">ListItemStyle</a></li><li><a href="ListStyle.html">ListStyle</a></li><li><a href="Property.html">Property</a></li><li><a href="Row.html">Row</a></li><li><a href="StringHelper.html">StringHelper</a></li><li><a href="Style.html">Style</a></li><li><a href="Table.html">Table</a></li><li><a href="TableAttributes.html">TableAttributes</a></li><li><a href="TableCellStyle.html">TableCellStyle</a></li><li><a href="TableRowStyle.html">TableRowStyle</a></li><li><a href="TableStyle.html">TableStyle</a></li><li><a href="Tag.html">Tag</a></li><li><a href="Unit.html">Unit</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#appendCell">appendCell</a></li><li><a href="global.html#appendElem">appendElem</a></li><li><a href="global.html#appendElemIfNotEmpty">appendElemIfNotEmpty</a></li><li><a href="global.html#appendItem">appendItem</a></li><li><a href="global.html#appendList">appendList</a></li><li><a href="global.html#appendProperty">appendProperty</a></li><li><a href="global.html#appendRow">appendRow</a></li><li><a href="global.html#appendStyle">appendStyle</a></li><li><a href="global.html#appendStyleToCellAt">appendStyleToCellAt</a></li><li><a href="global.html#appendStyleToCol">appendStyleToCol</a></li><li><a href="global.html#appendStyleToElemAt">appendStyleToElemAt</a></li><li><a href="global.html#attr">attr</a></li><li><a href="global.html#attr[undefined]">attr[undefined]</a></li><li><a href="global.html#bogusCellAttr">bogusCellAttr</a></li><li><a href="global.html#bogusCellStyle">bogusCellStyle</a></li><li><a href="global.html#bogusRowAttr">bogusRowAttr</a></li><li><a href="global.html#bogusRowStyle">bogusRowStyle</a></li><li><a href="global.html#bogusTableAttr">bogusTableAttr</a></li><li><a href="global.html#bogusTableStyle">bogusTableStyle</a></li><li><a href="global.html#cellNum">cellNum</a></li><li><a href="global.html#cellpadding">cellpadding</a></li><li><a href="global.html#cellspacing">cellspacing</a></li><li><a href="global.html#colNum">colNum</a></li><li><a href="global.html#color">color</a></li><li><a href="global.html#columnWidths">columnWidths</a></li><li><a href="global.html#concatDropSpaces">concatDropSpaces</a></li><li><a href="global.html#content">content</a></li><li><a href="global.html#crack">crack</a></li><li><a href="global.html#createCellFromHtml">createCellFromHtml</a></li><li><a href="global.html#createLinkFromHtml">createLinkFromHtml</a></li><li><a href="global.html#createListFromHtml">createListFromHtml</a></li><li><a href="global.html#createListItemFromHtml">createListItemFromHtml</a></li><li><a href="global.html#createOlFromHtml">createOlFromHtml</a></li><li><a href="global.html#createRowFromHtml">createRowFromHtml</a></li><li><a href="global.html#createTableFromHtml">createTableFromHtml</a></li><li><a href="global.html#createTagFromHtml">createTagFromHtml</a></li><li><a href="global.html#createUlFromHtml">createUlFromHtml</a></li><li><a href="global.html#desintangle">desintangle</a></li><li><a href="global.html#dropCell">dropCell</a></li><li><a href="global.html#dropCellAt">dropCellAt</a></li><li><a href="global.html#dropColAt">dropColAt</a></li><li><a href="global.html#dropColumn">dropColumn</a></li><li><a href="global.html#dropElemAt">dropElemAt</a></li><li><a href="global.html#dropFirst">dropFirst</a></li><li><a href="global.html#dropLast">dropLast</a></li><li><a href="global.html#dropProtocol">dropProtocol</a></li><li><a href="global.html#dropRow">dropRow</a></li><li><a href="global.html#elements">elements</a></li><li><a href="global.html#fileExt">fileExt</a></li><li><a href="global.html#findAscendant">findAscendant</a></li><li><a href="global.html#firstLetterUpperCase">firstLetterUpperCase</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#getBogusCellAttr">getBogusCellAttr</a></li><li><a href="global.html#getBogusCellProp">getBogusCellProp</a></li><li><a href="global.html#getBogusCellStyle">getBogusCellStyle</a></li><li><a href="global.html#getBogusRowAttr">getBogusRowAttr</a></li><li><a href="global.html#getBogusRowProp">getBogusRowProp</a></li><li><a href="global.html#getBogusRowStyle">getBogusRowStyle</a></li><li><a href="global.html#getBogusTableAttr">getBogusTableAttr</a></li><li><a href="global.html#getBogusTableProp">getBogusTableProp</a></li><li><a href="global.html#getBogusTableStyle">getBogusTableStyle</a></li><li><a href="global.html#getBorderInfo">getBorderInfo</a></li><li><a href="global.html#getCellWidths">getCellWidths</a></li><li><a href="global.html#getElem">getElem</a></li><li><a href="global.html#getFirst">getFirst</a></li><li><a href="global.html#getHref">getHref</a></li><li><a href="global.html#getLast">getLast</a></li><li><a href="global.html#getMatrix">getMatrix</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getProfile">getProfile</a></li><li><a href="global.html#getStyleProp">getStyleProp</a></li><li><a href="global.html#getWidth">getWidth</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#href">href</a></li><li><a href="global.html#insertCellAt">insertCellAt</a></li><li><a href="global.html#insertColAt">insertColAt</a></li><li><a href="global.html#insertColumn">insertColumn</a></li><li><a href="global.html#insertColumnAt">insertColumnAt</a></li><li><a href="global.html#insertElemAt">insertElemAt</a></li><li><a href="global.html#insertRow">insertRow</a></li><li><a href="global.html#isElemEmpty">isElemEmpty</a></li><li><a href="global.html#isEmpty">isEmpty</a></li><li><a href="global.html#isertItemAt">isertItemAt</a></li><li><a href="global.html#isFragmented">isFragmented</a></li><li><a href="global.html#isFramed">isFramed</a></li><li><a href="global.html#isLikeAs">isLikeAs</a></li><li><a href="global.html#isSameWidth">isSameWidth</a></li><li><a href="global.html#isTheSameAs">isTheSameAs</a></li><li><a href="global.html#itemNum">itemNum</a></li><li><a href="global.html#knockOutCell">knockOutCell</a></li><li><a href="global.html#knockOutCol">knockOutCol</a></li><li><a href="global.html#length">length</a></li><li><a href="global.html#loadFromHtml">loadFromHtml</a></li><li><a href="global.html#margin">margin</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nodeOffsetString">nodeOffsetString</a></li><li><a href="global.html#nodeString">nodeString</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#onlyFirstLetterUpperCase">onlyFirstLetterUpperCase</a></li><li><a href="global.html#onlyTableInside">onlyTableInside</a></li><li><a href="global.html#padding">padding</a></li><li><a href="global.html#propNum">propNum</a></li><li><a href="global.html#removeBorder">removeBorder</a></li><li><a href="global.html#resetBogus">resetBogus</a></li><li><a href="global.html#roundUp">roundUp</a></li><li><a href="global.html#rowNum">rowNum</a></li><li><a href="global.html#sandwichWith">sandwichWith</a></li><li><a href="global.html#sanitize">sanitize</a></li><li><a href="global.html#setAttr">setAttr</a></li><li><a href="global.html#setBorder">setBorder</a></li><li><a href="global.html#setCellWidths">setCellWidths</a></li><li><a href="global.html#setHref">setHref</a></li><li><a href="global.html#setName">setName</a></li><li><a href="global.html#setProfile">setProfile</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setWidth">setWidth</a></li><li><a href="global.html#specialChar">specialChar</a></li><li><a href="global.html#splitWeighted">splitWeighted</a></li><li><a href="global.html#str">str</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#sub">sub</a></li><li><a href="global.html#toHtml">toHtml</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#toText">toText</a></li><li><a href="global.html#trace">trace</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#validateWidth">validateWidth</a></li><li><a href="global.html#width">width</a></li><li></li><li></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha4</a> on Fri Mar 07 2014 12:35:59 GMT+0100 (ora solare Europa occidentale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
