<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>string.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Attributes.html">Attributes</a></li>
            
                <li><a href="../classes/BorderStyle.html">BorderStyle</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/createRowFromHtml.html">createRowFromHtml</a></li>
            
                <li><a href="../classes/createTableFromHtml.html">createTableFromHtml</a></li>
            
                <li><a href="../classes/ImageStyle.html">ImageStyle</a></li>
            
                <li><a href="../classes/isFramedTable.html">isFramedTable</a></li>
            
                <li><a href="../classes/LinkStyle.html">LinkStyle</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemStyle.html">ListItemStyle</a></li>
            
                <li><a href="../classes/ListStyle.html">ListStyle</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/Style.html">Style</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/TableAttributes.html">TableAttributes</a></li>
            
                <li><a href="../classes/TableCellStyle.html">TableCellStyle</a></li>
            
                <li><a href="../classes/TableRowStyle.html">TableRowStyle</a></li>
            
                <li><a href="../classes/TableStyle.html">TableStyle</a></li>
            
                <li><a href="../classes/TextStyle.html">TextStyle</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attributes.html">attributes</a></li>
            
                <li><a href="../modules/helpers.html">helpers</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/String.html">String</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: string.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global DOMParser, Node, flatten, Attributes, Style, Cell, getProperty, TableRowStyle, setMinMaxWidth, Row, onlyFirstLetterUpperCase, ListItem, Table */

/**
 * Transforms a row-html string into a Row object. It is supposed that the string to process is of the
 * following form: &lt;tr ... &gt; ... &lt;/tr&gt;. Inside the tag, there might be elements &quot;td&quot; that will be
 * processed one by one by function String::createCellFromHtml().
 * @module  String
 * @class   createRowFromHtml
 * @method  createRowFromHtml
 * @return  {Object} Row
 */
String.prototype.createRowFromHtml = function(){
		var htmlStr = this,
			parser = new DOMParser(),
			fullTable  = &#x27;&lt;table&gt;&lt;tbody&gt;&#x27; + htmlStr + &#x27;&lt;/tbody&gt;&lt;/table&gt;&#x27;,
			doc = parser.parseFromString(fullTable, &#x27;text/html&#x27;),
			node = doc.getElementsByTagName(&#x27;tr&#x27;),
			attrs, i, nodeStyle, cellsNum, currentCell, row, cell, cells;
		if (node.length === 0){
			return null;
		}
		// the first table row is to be processed. The remaining ones will be processed at thier turn.
		node = node[0];
		// object to return
		row = new Row();

		// imposing its styles
		nodeStyle = node.getAttribute(&#x27;style&#x27;);
		row.style = new Style(nodeStyle);

		// imposing its attributes
		attrs = flatten(node.attributes);
		if (attrs.hasOwnProperty(&#x27;style&#x27;)){
			delete attrs.style;
		}
		row.attr = new Attributes(attrs);

		cells = node.children;
		cellsNum = cells.length;
		for (i = 0; i &lt; cellsNum; i++){
			currentCell = cells[i];
			if(currentCell.tagName === &quot;TD&quot;){
				cell = currentCell.outerHTML.createCellFromHtml();
				row.appendCell(cell);
			}
		}
		return row;
};

/**
 * Transforms a cell-html string into Cell object. It is supposed that the string to process is of the
 * following form: &lt;td ... &gt; ... &lt;/td&gt;. Inside the tag, there might be other nodes. If they are recognized
 * as a &quot;supported&quot; ones, the corresponding functions will be called to transform them into objects.
 * For the moment, the only supported element is &quot;Table&quot;.
 * @module  String
 * @class   createTableFromHtml
 * @method  createCellFromHtml
 * @return  {Object} Cell
 */
String.prototype.createCellFromHtml = function(){
        var htmlStr = this,
            parser = new DOMParser(),
            newParser = new DOMParser(),
            fullTable = &#x27;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&#x27; + htmlStr + &#x27;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#x27;,
            doc = parser.parseFromString(fullTable, &#x27;text/html&#x27;),
            node = doc.getElementsByTagName(&#x27;td&#x27;),
            newDoc, cell, attrs, i, nodeStyle, elem, elems, elemsNum, currentElem, id, nodeContent, nodeText;
        if (node.length === 0){
            return null;
        }
        // process the first cell in the list of cells. The remaining cells are to be processed at their turn (when each of the becomes first)
        node = node[0];

        // creating object
        cell = new Cell();

        // imposing its styles
        nodeStyle = node.getAttribute(&#x27;style&#x27;);
        cell.style = new Style(nodeStyle);

        // imposing its attributes
        attrs = flatten(node.attributes);
        if (attrs.hasOwnProperty(&#x27;style&#x27;)){
            delete attrs.style;
        }
        cell.attr = new Attributes(attrs);

        // create a fictious div containing the cell and assign a unique id to it
        id = &quot;fakeDivId&quot; + Math.floor((Math.random()*99)+1);
        while (doc.getElementById(id)){
            id += Math.floor((Math.random()*99)+1);
        }
        nodeText = &#x27;&lt;div id=&quot;&#x27;+ id +&#x27;&quot;&gt;&#x27; + node.innerHTML + &#x27;&lt;/div&gt;&#x27;;

        newDoc = newParser.parseFromString(nodeText, &#x27;text/html&#x27;);
        nodeContent = newDoc.getElementById(id);

        elems = nodeContent.childNodes;

        elemsNum = elems.length;
        for (i = 0; i &lt; elemsNum; i++){
            currentElem = elems[i];
            switch (currentElem.nodeType){
                case Node.TEXT_NODE:
                    elem = currentElem.textContent;
                    break;
                case Node.ELEMENT_NODE:
                    elem = (currentElem.nodeName === &#x27;TABLE&#x27;) ? currentElem.outerHTML.createTableFromHtml() : currentElem.outerHTML;
                    break;
                default:
                    elem = currentElem.nodeValue;
            }
            cell.insert(elem);
        }
        return cell;
};

/**
 * Transforms a list item string into a ListItem object. It is supposed that the string to process is of the
 * following form: &lt;li ... &gt; ... &lt;/li&gt;. Inside the tag, there might be other nodes. If they are recognized
 * as a &quot;supported&quot; ones, the corresponding functions will be called to transform them into objects.
 * @module  String
 * @class   createTableFromHtml
 * @method  createListItemFromHtml
 * @return  {Object} ListItem
 */
String.prototype.createListItemFromHtml = function(){
        var htmlStr = this,
            parser = new DOMParser(),
            newParser = new DOMParser(),
            fullList = &#x27;&lt;ul&gt;&#x27; + htmlStr + &#x27;&lt;/ul&gt;&#x27;, // embedding the table inside &#x27;ul&#x27; element.
            doc = parser.parseFromString(fullList, &#x27;text/html&#x27;),
            node = doc.getElementsByTagName(&#x27;li&#x27;),
            newDoc, listItem, attrs, i, nodeStyle, elem, elems, elemsNum, currentElem, id, nodeContent, nodeText, methodToCall, nodeName;
        if (node.length === 0){
            return null;
        }
        // process the first element among the found ones. The remaining elements
        // are to be processed at their turn (when each of the becomes first)
        node = node[0];

        // creating object
        listItem = new ListItem();

        // imposing its styles
        nodeStyle = node.getAttribute(&#x27;style&#x27;);
        listItem.style = new Style(nodeStyle);

        // imposing its attributes
        attrs = flatten(node.attributes);
        if (attrs.hasOwnProperty(&#x27;style&#x27;)){
            delete attrs.style;
        }
        listItem.attr = new Attributes(attrs);

        // create a fictious div containing the listItem and assign a unique id to it
        id = &quot;fakeDivId&quot; + Math.floor((Math.random()*99)+1);
        while (doc.getElementById(id)){
            id += Math.floor((Math.random()*99)+1);
        }
        nodeText = &#x27;&lt;div id=&quot;&#x27;+ id +&#x27;&quot;&gt;&#x27; + node.innerHTML + &#x27;&lt;/div&gt;&#x27;;

        newDoc = newParser.parseFromString(nodeText, &#x27;text/html&#x27;);
        nodeContent = newDoc.getElementById(id);

        elems = nodeContent.childNodes;

        elemsNum = elems.length;
        for (i = 0; i &lt; elemsNum; i++){
            currentElem = elems[i];
            switch (currentElem.nodeType){
                case Node.TEXT_NODE:
                    elem = currentElem.textContent;
                    break;
                case Node.ELEMENT_NODE:
                    nodeName = currentElem.nodeName;
                    methodToCall = &#x27;create&#x27; + onlyFirstLetterUpperCase(nodeName) + &#x27;FromHtml&#x27;;
                    elem = String.prototype.hasOwnProperty(methodToCall) ? currentElem.outerHTML[methodToCall]() : currentElem.outerHTML;
                    break;
                default:
                    elem = currentElem.nodeValue;
            }
            listItem.appendElem(elem);
        }
        return listItem;
};

/**
 * Creates an object representation from a string that is an html repersentation of a table.
 * Only one table is supposed to be processed at a time, so the string to be processed is to
 * be of the following form &amp;lt;table ...&amp;gt; ... &amp;lt;/table&amp;gt;. Inside the tag, there should be tags &quot;tr&quot;
 * that will be processed one by one by function String::createRowFromHtml().
 * @module  String
 * @class   createTableFromHtml
 * @method  createTableFromHtml
 * @return  {Table}
 */
String.prototype.createTableFromHtml = function(){
        var htmlStr = this,
            isFramed = htmlStr.isFramedTable(),
            parser = new DOMParser(),
            doc = parser.parseFromString(htmlStr, &#x27;text/html&#x27;),
            node = doc.getElementsByTagName(&#x27;table&#x27;),

            table, attrs, i, nodeStyle, rows, rowsNum, currentRow, row,
            bogusRowAttr, bogusRowStyle, bogusCellAttr, bogusCellStyle, bogusTableAttr, bogusTableStyle;
        if (node.length === 0){
            return null;
        }
        node = node[0];

        // creating table
        table = new Table();

        // imposing table styles
        nodeStyle = node.getAttribute(&#x27;style&#x27;);
        table.style = new Style(nodeStyle);
        // imposing table attributes
        attrs = flatten(node.attributes);
        if (attrs.hasOwnProperty(&#x27;style&#x27;)){
            delete attrs.style;
        }
        table.attr = new Attributes(attrs);

        // the only child of the table is always tbody
        rows = node.children[0].children;
        rowsNum = rows.length;

        if (isFramed){
            console.log(&#x27;the table seems to be framed&#x27;);
            bogusRowStyle = node.querySelector(&#x27;tr&#x27;).getAttribute(&#x27;style&#x27;);
            bogusCellStyle = node.querySelector(&#x27;tr td&#x27;).getAttribute(&#x27;style&#x27;);
            bogusTableStyle = node.querySelector(&#x27;tr td table&#x27;).getAttribute(&#x27;style&#x27;);

            bogusRowAttr = flatten(node.querySelector(&#x27;tr&#x27;).attributes);
            if (bogusRowAttr.hasOwnProperty(&#x27;style&#x27;)){
                delete bogusRowAttr.style;
            }

            bogusCellAttr = flatten(node.querySelector(&#x27;tr td&#x27;).attributes);
            if (bogusCellAttr.hasOwnProperty(&#x27;style&#x27;)){
                delete bogusCellAttr.style;
            }

            bogusTableAttr = flatten(node.querySelector(&#x27;tr td table&#x27;).attributes);
            if (bogusTableAttr.hasOwnProperty(&#x27;style&#x27;)){
                delete bogusTableAttr.style;
            }
            table.bogusRowStyle   = new Style(bogusRowStyle);
            table.bogusRowAttr    = new Attributes(bogusRowAttr);
            table.bogusCellStyle  = new Style(bogusCellStyle);
            table.bogusCellAttr   = new Attributes(bogusCellAttr);
            table.bogusTableStyle = new Style(bogusTableStyle);
            table.bogusTableAttr  = new Attributes(bogusTableAttr);
        }


        // console.log(&#x27;numero di righe rilevate:&#x27;, childNum);
        for (i = 0; i &lt; rowsNum; i++){
            if (isFramed){
                currentRow = rows[i].querySelector(&#x27;td table tr&#x27;);
            } else {
                currentRow = rows[i];
            }

            if(currentRow.tagName === &quot;TR&quot;){
                // console.log(child);
                row = currentRow.outerHTML.createRowFromHtml();
                table.appendRow(row);
            }
        }
        return table;
};

/**
 * Returns true, if tableHtml is an html code corresponding to a table each row of which
 * contains just one cell, and this cell in its turn contains only one table.
 * Returns false otherwise.
 * @module  String
 * @class   isFramedTable
 * @method  isFramedTable
 * @return  {Boolean}
 */
String.prototype.isFramedTable = function (){
    var tableHtml = this,
        parser = new DOMParser(),
        doc = parser.parseFromString(tableHtml, &#x27;text/html&#x27;),
        node = doc.getElementsByTagName(&#x27;table&#x27;),
        isFramed = true,
        tableChildren, tableChildrenLen, currentElem, elemChildren, nestedElem, nestedElemChildren, i;

        // it would be very nice to use this approach, but doc.evaluate always returns &quot;undefined&quot;
        // try{
        //  var tmp = doc.evaluate(&#x27;//*&#x27;, doc, null, XPathResult.ANY_TYPE, tmp);
        //  console.log(&#x27;evaluate: &#x27;, tmp);
        // } catch (ex){
        //  console.log(&quot;Error! &quot;, ex);
        // }

        if (node.length === 0){
            return false;
        }
        node = node[0];

        // parsing the table structure to decide whether this is a framed table or a regular one.
        tableChildren = node.children[0].children;   // all rows of  the table
        tableChildrenLen = tableChildren.length;
        for (i = 0; i &lt; tableChildrenLen; i++) {
            currentElem = tableChildren[i];          // current row
            elemChildren = currentElem.children;     // all cells inside the row
            if (elemChildren.length !== 1 ){
                isFramed = false;
                break;
            }
            nestedElem = elemChildren[0];     // first cell inside the row
            if (nestedElem.tagName !== &#x27;TD&#x27;){
                isFramed = false;
                break;
            }
            nestedElemChildren = nestedElem.children;
            if (nestedElemChildren.length !== 1 || nestedElemChildren[0].tagName !== &#x27;TABLE&#x27;){
                isFramed = false;
                break;
            }
        }
        return isFramed;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
