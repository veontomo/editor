<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>classes\table.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Attributes.html">Attributes</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/ImageStyle.html">ImageStyle</a></li>
            
                <li><a href="../classes/LinkStyle.html">LinkStyle</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemStyle.html">ListItemStyle</a></li>
            
                <li><a href="../classes/ListStyle.html">ListStyle</a></li>
            
                <li><a href="../classes/Property.html">Property</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/StringHelper.html">StringHelper</a></li>
            
                <li><a href="../classes/Style.html">Style</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/TableAttributes.html">TableAttributes</a></li>
            
                <li><a href="../classes/TableCellStyle.html">TableCellStyle</a></li>
            
                <li><a href="../classes/TableRowStyle.html">TableRowStyle</a></li>
            
                <li><a href="../classes/TableStyle.html">TableStyle</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Property.html">Property</a></li>
            
                <li><a href="../modules/String.html">String</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: classes\table.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global DOMParser, Node, flatten, Attributes, Style, Cell, getProperty, TableStyle, TableAttributes, Row, setMinMaxWidth, Tag */

/**
* Represents table.
* @module  HtmlElements
* @class   Table
* @extends Tag
*/
function Table() {
	&quot;use strict&quot;;
	if (!(this instanceof Table)) {
		return new Table();
	}
	// inherit tag properties
	Tag.call(this);

	/**
	 * Type of the object. Returns &quot;Table&quot; for the objects of this type.
	 * @method  {string} getType
	 * @return  {string}
	 * @deprecated  in favor of getName()
	 */
	this.getType = function(){
		return &quot;Table&quot;;
	};

	/**
	 * Html tag corresponding to Table instances.
	 * @property {String}    name
	 * @type     {String}
	 * @default  table
	 */
	this.name = &#x27;table&#x27;;

	/**
	* Attributes of the table. Overrides parent property &quot;attr&quot;.
	* @property {TableAttributes} attr
	* @type {TableAttributes}
	* @default TableAttributes
	*/
	this.attr = new TableAttributes();

	/**
	 * Styles of the row. Overrides parent property &quot;style&quot;.
	 * @property {TableStyle} style
	 * @type {TableStyle}
	 * @default TableStyle
	 */
	this.style = new TableStyle();

	/**
	 * The number of the rows in the table. Alias of length() of the parent class.
	 * @method  rowNum
	 * @return {Number}
	 */
	this.rowNum = function(){
		return this.length();
	};

	/**
	 * Appends a row to the content property. If the argument is not a Row instance, an error is thrown.
	 * @method   appendRow
	 * @param    {Object} row     a row to append. If not a Row instance, an error is thrown.
	 * @return   {void}
	 */
	this.appendRow = function(row){
		if (!(row instanceof Row)){
			throw new Error(&#x27;The argument is not a Row instance!&#x27;);
		}
		this.appendElem(row);
	};

	/**
	 * Gives a two-dimensional array [[w_11, w_12, ..., w_1n], ..., [w_m1, w_m2, ..., w_m3]]
	 * where w_ij is width of the cell located in the row i and column j.
	 * @method  getMatrix
	 * @return {Array}
	 */
	this.getMatrix = function(){
		var output = [],
			rowsNum = this.rowNum(), i;
		for (i = 0; i &lt; rowsNum; i++){
			output.push(this.getElem(i).getCellWidths());
		}
		return output;
	};

	/**
	 * Returns array of widths of the cells in the table rows if all rows
	 * have the same cell widths. Otherwise null is returned.
	 * @method  getProfile
	 * @return {Array|Null}
	 */
	this.getProfile = function (){
		return this.isSameWidths() ? this.getMatrix()[0] : null;
	};

	/**
	 * Imposes the widths of all cell in all rows of the table. If the argument is not array, an error is thrown.
	 * If the array length is different from the number of columns, an error is thrown. Otherwise, it is called
	 * method of Row::setCellWidths on each table row.
	 * @method  setProfile
	 * @param   {Array}   profile      an array of cell widths that will be applied to each row.
	 * @return  {void}
	 */
	this.setProfile = function(profile){
		var len = this.rowNum(),
			cols = this.colNum(),
			i;
		if (!Array.isArray(profile)){
			throw new Error(&#x27;Wrong argument type: array expected.&#x27;);
		}
		if (profile.length !== cols){
			throw new Error(&#x27;Wrong input array lenght!&#x27;);
		}
		for (i = 0; i &lt; len; i++){
			this.getElem(i).setCellWidths(profile);
		}
	};

	/**
	 * Inserts a cell &quot;cell&quot; into a given position &quot;pos&quot; of each row of the table.
	 * If the table has 5 columns, then after insertion it will have 5+1=6 columns.
	 * Position &quot;pos&quot; will correspond to the index of the inserted cell in the row after insertion.
	 * &quot;pos&quot; must be a valid cell number into the table after insertion. So, for the example above,
	 * the valid values for &quot;pos&quot; are 0, 1, 2, 3, 4 and 5.
	 * @method insertColAt
	 * @param  {Cell} 	cell
	 * @param  {Number} pos
	 * @return {void}
	 */
	this.insertColAt = function(pos, cell){
		cell = cell || (new Cell());
		var colNum = this.colNum(),
			rowNum = this.rowNum(),
			i;

		if (colNum &lt;= 0 || pos &lt; 0 || pos &gt; colNum){
			throw new Error(&#x27;Wrong index for the cell to insert!&#x27;);
		}
		if (pos &lt; colNum){
			for (i = 0; i &lt; rowNum; i++){
				this.getElem(i).insertCellAt(pos, cell);
			}
		} else {
			for (i = 0; i &lt; rowNum; i++){
				this.getElem(i).appendCell(cell);
			}
		}
		return null;
	};

	/**
	 * Knocks out given column from the table. The operation is delegated to the &#x60;Row::knockOutCell()&#x60;
	 * @method knockOutCol
	 * @param  {integer} 	colNum        the number of the column to be knocked out. Numeration starts with 0.
	 * @return {void}
	 */
	this.knockOutCol = function(colNum){
		var rowsNum = this.rowNum(),
		i;
		for (i = 0; i &lt; rowsNum; i++){
			this.getElem(i).knockOutCell(colNum);
		}
	};

	/**
	 * Drops specified column from the table. The operation is delegated to the &#x60;Row::dropCellAt()&#x60;
	 * @method dropColAt
	 * @param  {integer} 	colNum           the number of the column to delete. Numeration starts with 0.
	 * @return {void}
	 */
	this.dropColAt = function(colNum){
		var rowsNum = this.rowNum(),
		i;
		for (i = 0; i &lt; rowsNum; i++){
			this.getElem(i).dropCellAt(colNum);
		}
	};

	/**
	 * Gives the number of columns in the table or null if not all rows have the same number of cells.
	 * The operation is delegated to the &#x60;Row::cellNum()&#x60;.
	 * @method  colNum
	 * @return {Number|null}
	 */
	this.colNum = function(){
		var rowNum = this.rowNum(),
			firstRowCellNum, i;
		// if table has no rows, return 0 as number of column
		if (rowNum === 0){
			return 0;
		}
		firstRowCellNum = this.getElem(0).cellNum();
		// if the table has a unique row
		if (rowNum === 1){
			return firstRowCellNum;
		}

		for (i = 1; i &lt; rowNum; i++){
			if (this.getElem(i).cellNum() !== firstRowCellNum){
				return null;
			}
		}
		return firstRowCellNum;
	};

	/**
	 * Whether all rows in the table have the same cell widths.
	 * @method isSameWidth
	 * @return {Boolean} true, if all rows have the same cells&#x27; widths, false otherwise.
	 */
	this.isSameWidths = function(){
		var matrix = this.getMatrix(),
			rowsNum = matrix.length,
			output = true,
			firstRow, firstRowLen, i, j;
		// only if the number of rows is bigger than 1
		if (rowsNum &gt; 1){
			// compare the first row with the rest
			firstRow = matrix[0];
			firstRowLen = firstRow.length;
			for (i = 1; i &lt; rowsNum; i++){
				if (matrix[i].length !== firstRowLen){
					output = false;
					break;
				}
				// compare element by element
				for (j = 0; j &lt; firstRowLen; j++){
					if(matrix[i][j] !== firstRow[j]){
						output = false;
						break;
					}
				}
				// exit as well from outer loop if necessary
				if (!output){
					break;
				}
			}
		}
		return output;
	};

	/**
	 * Set the border of the table. It updates the properties &#x27;attr&#x27; and &#x27;style&#x27; of the instance:
	 * 1. in &#x27;style&#x27; property, sets up the following properties: &#x27;border-width&#x27;, &#x27;border-color&#x27; and &#x27;border-style&#x27;
	 * 2. in &#x27;attr&#x27; property, sets up &#x27;border&#x27; property.
	 * Note that if after setting the border there is an assigment of &#x27;style&#x27; or &#x27;attr&#x27; property, then some info about the border might be overwritten.
	 * @method  setBorder
	 * @param   {Object}     borderInfo        Object containing &#x27;width&#x27;, &#x27;color&#x27; and &#x27;style&#x27; for the border to set.
	 * @default border-width is set to 1, border-color is set to #000000, border-style is set to solid.
	 * @return {void}
	 */
	this.setBorder = function(borderInfo){
		var bw, bc, bs;
		if (borderInfo === undefined){
			borderInfo = {&#x27;width&#x27;: 1, &#x27;color&#x27;: &#x27;#000000&#x27;, &#x27;style&#x27;: &#x27;solid&#x27;};
		}
		bw = borderInfo.width || 1;
		bc = borderInfo.color || &#x27;#000000&#x27;;
		bs = borderInfo.style || &#x27;solid&#x27;;

		this.style[&#x27;border-width&#x27;] = bw;
		this.style[&#x27;border-color&#x27;] = bc;
		this.style[&#x27;border-style&#x27;] = bs;
		this.attr.border = bw;
	};

	/**
	 * Removes the border of the table. It updates the properties &#x27;attr&#x27; and &#x27;style&#x27; of the instance:
	 * 1. in &#x27;style&#x27; property, deletes the properties: &#x27;border-width&#x27;, &#x27;border-color&#x27; and sets up &#x27;border-style&#x27; to &#x27;none&#x27;
	 * 2. in &#x27;attr&#x27; property, deletes &#x27;border&#x27; property.
	 * @method  removeBorder
	 * @return {void}
	 */
	this.removeBorder = function(){
		if (this.style.hasOwnProperty(&#x27;border-width&#x27;)) {
			delete this.style[&#x27;border-width&#x27;];
		}
		if (this.style.hasOwnProperty(&#x27;border-color&#x27;)) {
			delete this.style[&#x27;border-color&#x27;];
		}
		this.style[&#x27;border-style&#x27;] = &#x27;none&#x27;;

		if (this.attr.hasOwnProperty(&#x27;border&#x27;)) {
			delete this.attr.border;
		}
	};

	/**
	 * Returns true if the table is framed, and false otherwise. It takes table rows and call method
	 * &#x60;Row::onlyTableInside()&#x60; on each of them until first &quot;false&quot; is encountered.
	 * &lt;br /&gt;A table is a __framed table__ if all table rows have only one cell and this cell contains
	 * only one element that is a Table instance.
	 * @method     isFragmented
	 * @return     {Boolean}       true if the table is framed, and false otherwise
	 */
	this.isFragmented = function(){
		if (this.rowNum() === 0){
			return false;
		}
		return this.content.elements.every(function(row){
			return row.onlyTableInside();
		});
	};

	/**
	 * Gives true if all table rows have border around (that is, each row is nothing but a table with border)
	 * false otherwise. It at least one of the properties, corresponding to the &quot;bogus&quot; elements is set, then
	 * the table is considered as being framed and hence all its rows will be framed.
	 * @method isFramed
	 * @return {Boolean}     true, if all table rows have border around
	 */
	this.isFramed = function(){
		// if at least one of these properties is set, the table is considered as being framed.
		var propertyList = [&#x27;bogusRowStyle&#x27;, &#x27;bogusRowAttr&#x27;, &#x27;bogusCellStyle&#x27;,
							&#x27;bogusCellAttr&#x27;, &#x27;bogusTableStyle&#x27;, &#x27;bogusTableAttr&#x27;],
			that = this;
		return propertyList.some(function(prop){
			return (that[prop] !== undefined) &amp;&amp;  that[prop];
		});
	};

	/**
	 * Resets bogus properties. After resetting those properties, the table becomes a table without frame.
	 * @method resetBogus
	 * @return {void}
	 */
	this.resetBogus = function(){
		var propertyList = [&#x27;bogusRowStyle&#x27;, &#x27;bogusRowAttr&#x27;, &#x27;bogusCellStyle&#x27;,
							&#x27;bogusCellAttr&#x27;, &#x27;bogusTableStyle&#x27;, &#x27;bogusTableAttr&#x27;],
			propertyListLen = propertyList.length,
			i;
		for (i = 0; i &lt; propertyListLen; i++){
			if(this.hasOwnProperty(propertyList[i])){
				delete this[propertyList[i]];
			}
		}
	};

	/**
	 * Appends the style to the column. If the column exists, the method call &#x60;Row::appendStyleToCell()&#x60;
	 * on each of the table rows.
	 * @method appendStyleToCol
	 * @param  {Number}        colNum    column number to which the style is to be appended.
	 * @param  {Style|Object}  style     Style or Object to be appended
	 * @return {void}
	 */
	this.appendStyleToCol = function(colNum, style){
		var colNumInt = parseInt(colNum, 10),
			colLen = this.colNum(),
			rowLen = this.rowNum(),
			i;
		if (colNumInt === colNum &amp;&amp; colNum &gt;= 0 &amp;&amp; colNum &lt; colLen) {
			for (i = 0; i &lt; rowLen; i++){
				this.getElem(i).appendStyleToCellAt(colNum, style);
			}
		} else {
			throw new Error(&#x27;The column is not present!&#x27;);
		}


	};

	/**
	 * Generates table-specific html code with corresponding attributes and styles.
	 * Creation of the row-related html of each row is delegated to &#x60;Row::toHtml()&#x60;
	 * @method toHtml
	 * @return {String}
	 */
	this.toHtml = function () {
		var prologue = &#x27;&#x27;, epilogue = &#x27;&#x27;, tableTag = &#x27;table&#x27;, rowTag = &#x27;tr&#x27;, cellTag = &#x27;td&#x27;,
			bogusRowAttr, bogusRowStyle, bogusCellAttr, bogusCellStyle, bogusTableAttr, bogusTableStyle,
			bogusRowHtml, bogusCellHtml, bogusTableHtml, tableAttr, tableStyle, tableHtml, i, rowsNumber;

		if (this.isFramed()){
			// some preliminaries for the framed tables
			bogusRowAttr    = this.bogusRowAttr    ? this.bogusRowAttr.toString() : &#x27;&#x27;;
			bogusRowStyle   = this.bogusRowStyle   ? this.bogusRowStyle.toString().sandwichWith(&#x27;style=&quot;&#x27;, &#x27;&quot;&#x27;) : &#x27;&#x27;;
			bogusCellAttr   = this.bogusCellAttr   ? this.bogusCellAttr.toString() : &#x27;&#x27;;
			bogusCellStyle  = this.bogusCellStyle  ? this.bogusCellStyle.toString().sandwichWith(&#x27;style=&quot;&#x27;, &#x27;&quot;&#x27;) : &#x27;&#x27;;
			bogusTableAttr  = this.bogusTableAttr  ? this.bogusTableAttr.toString() : &#x27;&#x27;;
			bogusTableStyle = this.bogusTableStyle ? this.bogusTableStyle.toString().sandwichWith(&#x27;style=&quot;&#x27;, &#x27;&quot;&#x27;) : &#x27;&#x27;;

			bogusRowHtml = [rowTag, bogusRowAttr, bogusRowStyle].concatDropSpaces().sandwichWith(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;);
			bogusCellHtml = [cellTag, bogusCellAttr, bogusCellStyle].concatDropSpaces().sandwichWith(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;);
			bogusTableHtml = [tableTag, bogusTableAttr, bogusTableStyle].concatDropSpaces().sandwichWith(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;);

			epilogue = bogusRowHtml + bogusCellHtml + bogusTableHtml;
			prologue = tableTag.sandwichWith(&#x27;&lt;/&#x27;, &#x27;&gt;&#x27;) + cellTag.sandwichWith(&#x27;&lt;/&#x27;, &#x27;&gt;&#x27;) + rowTag.sandwichWith(&#x27;&lt;/&#x27;, &#x27;&gt;&#x27;);
		}
		tableAttr  = this.attr  ? this.attr.toString() : &#x27;&#x27;;
		tableStyle = this.style ? this.style.toString().sandwichWith(&#x27;style=&quot;&#x27;, &#x27;&quot;&#x27;) : &#x27;&#x27;;
		tableHtml  = [tableTag, tableAttr, tableStyle].concatDropSpaces().sandwichWith(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;);
		rowsNumber = this.rowNum();
		for (i = 0; i &lt; rowsNumber; i++) {
			tableHtml += epilogue;
			tableHtml += this.getElem(i).toHtml();
			tableHtml += prologue;
		}
		tableHtml += tableTag.sandwichWith(&#x27;&lt;/&#x27;, &#x27;&gt;&#x27;);
		return tableHtml;
	};

	/**
	 * Style of the row containing a single cell. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Style} bogusRowStyle
	 * @default  null
	 */
	this.bogusRowStyle = null; // new TableRowStyle();

	/**
	 * Attributes of the row containing a single cell. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusRowAttr
	 * @default  null
	 */
	this.bogusRowAttr = null; // new Attributes();

	/**
	 * Style of the  the cell which fills the whole row. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {TableCellStyle} bogusCellStyle
	 * @default  null
	 */
	this.bogusCellStyle = null; // new TableCellStyle();

	/**
	 * Attributes of the  the cell which fills the whole row. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusCellAttr
	 * @default  null
	 */
	this.bogusCellAttr = null; // new Attributes();

	/**
	 * Style of the  the table that will be inserted into the single cell to create a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {TableStyle} bogusTableStyle
	 * @default  null
	 */
	this.bogusTableStyle = null; // new TableStyle();

	/**
	 * Attributes of the  the table that will be inserted into the single cell to create a table with framed lines.
 	 * It is supposed that all properties
 	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusTableAttr
	 * @default  null
	 */
	this.bogusTableAttr = null; // new Attributes();

	/**
	 * If the table is fragmented and all rows have the same requested property, then
	 * this property of the first row is returned. In any other case, null is returned.
	 * NB: to compare requested property for all rows, this property must be an object
	 * with boolean-valued method isTheSameAs().
	 * @method   getBogusRowProp
	 * @param    {String}         prop      a name of the property to return. All rows shiuld have this property.
	 * @return   {Object|null}			    the value of the property specified by the argument, if it is the same
	 *                                      for all rows, null otherwise.
	 */
	this.getBogusRowProp = function(prop){
		if (!this.isFragmented()){
			return null;
		}
		var firstRow = this.getFirst(),
			rowNum = this.rowNum(),
			rowProp, i, firstRowProp;
		if (firstRow.hasOwnProperty(prop)){
			firstRowProp = firstRow[prop];
		} else {
			return null;
		}
		if (rowNum === 1){
			return firstRowProp;
		}
		if (typeof firstRowProp.isTheSameAs !== &#x27;function&#x27;){
			return null;
		}
		for (i = 1; i &lt; rowNum; i++){
			rowProp = this.getElem(i)[prop];
			if (!firstRowProp.isTheSameAs(rowProp)){
				return null;
			}
		}
		return firstRowProp;

	};


	/**
	 * If the table is fragmented and all the rows have the same styles, then this style is returned.
	 * Otherwise, null is returned. This is an alias for &#x60;Table::getBogusRowProp(&#x27;style&#x27;)&#x60;.
	 * @method   getBogusRowStyle
	 * @return   {Style|null}
	 */
	this.getBogusRowStyle = function(){
		return this.getBogusRowProp(&#x27;style&#x27;);
	};

	/**
	 * If the table is fragmented and all the rows have the same styles, then this style is returned.
	 * Otherwise, null is returned. This is an alias for &#x60;Table::getBogusRowProp(&#x27;attr&#x27;)&#x60;.
	 * @method   getBogusRowAttr
	 * @return   {Attributes|null}
	 */
	this.getBogusRowAttr = function(){
		return this.getBogusRowProp(&#x27;attr&#x27;);
	};

	/**
	 * If the table is fragmented, gives the requested property of the bogus cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @param  {String}       propName
	 * @return {Object|null}
	 */
	this.getBogusCellProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getBogusCellProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getBogusCellProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;
	};
}
Table.prototype = Object.create(Tag.prototype);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
