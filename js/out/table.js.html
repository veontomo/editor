<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: table.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: table.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global DOMParser, Node, flatten, Attributes, Style, Cell, Helper, getProperty, TableStyle, TableAttributes, Row, setMinMaxWidth, Tag, Content */

/**
* Represents table.
* @module  HtmlElements
* @class   Table
* @extends Tag
*/
function Table() {
	// "use strict";
	if (!(this instanceof Table)) {
		return new Table();
	}
	// inherit tag properties
	Tag.call(this);

	/**
	 * Type of the object. Returns "Table" for the objects of this type.
	 * @method  {string} getType
	 * @return  {string}
	 * @deprecated  in favor of getName()
	 */
	this.getType = function(){
		return "Table";
	};

	/**
	 * Html tag corresponding to Table instances.
	 * @property {String}    name
	 * @type     {String}
	 * @default  table
	 */
	this.name = 'table';

	/**
	* Attributes of the table. Overrides parent property "attr".
	* @property {TableAttributes} attr
	* @type {TableAttributes}
	* @default TableAttributes
	*/
	this.attr = new TableAttributes();

	/**
	 * Styles of the row. Overrides parent property "style".
	 * @property {TableStyle} style
	 * @type {TableStyle}
	 * @default TableStyle
	 */
	this.style = new TableStyle();

	/**
	 * The number of the rows in the table. Alias of length() of the parent class.
	 * @method  rowNum
	 * @return {Number}
	 */
	this.rowNum = function(){
		return this.length();
	};

	/**
	 * Appends a row to the content property. If the argument is not a Row instance, an error is thrown.
	 * @method   appendRow
	 * @param    {Object} row     a row to append. If not a Row instance, an error is thrown.
	 * @return   {void}
	 */
	this.appendRow = function(row){
		if (!(row instanceof Row)){
			throw new Error('The argument is not a Row instance!');
		}
		this.appendElem(row);
	};

	/**
	 * Gives a two-dimensional array [[w_11, w_12, ..., w_1n], ..., [w_m1, w_m2, ..., w_m3]]
	 * where w_ij is width of the cell located in the row i and column j.
	 * @method  getMatrix
	 * @return {Array}
	 */
	this.getMatrix = function(){
		var output = [],
			rowsNum = this.rowNum(), i;
		for (i = 0; i &lt; rowsNum; i++){
			output.push(this.getElem(i).getCellWidths());
		}
		return output;
	};

	/**
	 * Returns array of widths of the cells in the table rows if all rows
	 * have the same cell widths. Otherwise null is returned.
	 * @method  getProfile
	 * @return {Array|Null}
	 */
	this.getProfile = function (){
		return this.isSameWidths() ? this.getMatrix()[0] : null;
	};

	/**
	 * Imposes the widths of all cell in all rows of the table. If the argument is not array, an error is thrown.
	 * If the array length is different from the number of columns, an error is thrown. Otherwise, it is called
	 * method of Row::setCellWidths on each table row.
	 * @method  setProfile
	 * @param   {Array}   profile      an array of cell widths that will be applied to each row.
	 * @return  {void}
	 */
	this.setProfile = function(profile){
		var len = this.rowNum(),
			cols = this.colNum(),
			i;
		if (!Array.isArray(profile)){
			throw new Error('Wrong argument type: array expected.');
		}
		if (profile.length !== cols){
			throw new Error('Wrong input array lenght!');
		}
		for (i = 0; i &lt; len; i++){
			this.getElem(i).setCellWidths(profile);
		}
	};

	/**
	 * Inserts a cell "cell" into a given position "pos" of each row of the table.
	 * If the table has 5 columns, then after insertion it will have 5+1=6 columns.
	 * Position "pos" will correspond to the index of the inserted cell in the row after insertion.
	 * "pos" must be a valid cell number into the table after insertion. So, for the example above,
	 * the valid values for "pos" are 0, 1, 2, 3, 4 and 5.
	 * @method insertColAt
	 * @param  {Cell} 	cell
	 * @param  {Number} pos
	 * @return {void}
	 */
	this.insertColAt = function(pos, cell){
		cell = cell || (new Cell());
		var colNum = this.colNum(),
			rowNum = this.rowNum(),
			i;

		if (colNum &lt;= 0 || pos &lt; 0 || pos > colNum){
			throw new Error('Wrong index for the cell to insert!');
		}
		if (pos &lt; colNum){
			for (i = 0; i &lt; rowNum; i++){
				this.getElem(i).insertCellAt(pos, cell);
			}
		} else {
			for (i = 0; i &lt; rowNum; i++){
				this.getElem(i).appendCell(cell);
			}
		}
		return null;
	};

	/**
	 * insertColumnAt was renamed into Table::insertColAt(). So, this method is added for back-compatibility .
	 * @method  insertColumnAt
	 * @param  {pos}      pos
	 * @param  {cell}     cell
	 * @return {void}
	 * @deprecated  Use Table::insertColAt() directly.
	 */
	this.insertColumnAt = function(pos, cell){
		console.log('Table::insertColumnAt() was called. Try to eliminate this call.');
		this.insertColAt(pos, cell);
	};

	/**
	 * Knocks out given column from the table. The operation is delegated to the `Row::knockOutCell()`
	 * @method knockOutCol
	 * @param  {integer} 	colNum        the number of the column to be knocked out. Numeration starts with 0.
	 * @return {void}
	 */
	this.knockOutCol = function(colNum){
		var rowsNum = this.rowNum(),
		i;
		for (i = 0; i &lt; rowsNum; i++){
			this.getElem(i).knockOutCell(colNum);
		}
	};

	/**
	 * dropColumn was renamed into Table::knockOutCol(). So, this method is added for back-compatibility .
	 * @method  dropColumn
	 * @param  {pos}      pos
	 * @param  {cell}     cell
	 * @return {void}
	 * @deprecated  Use Table::knockOutCol() directly.
	 */
	this.dropColumn = function(pos, cell){
		console.log('Table::dropColumn() was called. Try to eliminate this call by using Table::knockOutCol() directly.');
		this.knockOutCol(pos, cell);
	};


	/**
	 * Drops specified column from the table. The operation is delegated to the `Row::dropCellAt()`
	 * @method dropColAt
	 * @param  {integer} 	colNum           the number of the column to delete. Numeration starts with 0.
	 * @return {void}
	 */
	this.dropColAt = function(colNum){
		var rowsNum = this.rowNum(),
		i;
		for (i = 0; i &lt; rowsNum; i++){
			this.getElem(i).dropCellAt(colNum);
		}
	};

	/**
	 * Gives the number of columns in the table or null if not all rows have the same number of cells.
	 * The operation is delegated to the `Row::cellNum()`.
	 * @method  colNum
	 * @return {Number|null}
	 */
	this.colNum = function(){
		var rowNum = this.rowNum(),
			firstRowCellNum, i;
		// if table has no rows, return 0 as number of column
		if (rowNum === 0){
			return 0;
		}
		firstRowCellNum = this.getElem(0).cellNum();
		// if the table has a unique row
		if (rowNum === 1){
			return firstRowCellNum;
		}

		for (i = 1; i &lt; rowNum; i++){
			if (this.getElem(i).cellNum() !== firstRowCellNum){
				return null;
			}
		}
		return firstRowCellNum;
	};

	/**
	 * Whether all rows in the table have the same cell widths.
	 * @method isSameWidth
	 * @return {Boolean} true, if all rows have the same cells' widths, false otherwise.
	 */
	this.isSameWidths = function(){
		var matrix = this.getMatrix(),
			rowsNum = matrix.length,
			output = true,
			firstRow, firstRowLen, i, j;
		// only if the number of rows is bigger than 1
		if (rowsNum > 1){
			// compare the first row with the rest
			firstRow = matrix[0];
			firstRowLen = firstRow.length;
			for (i = 1; i &lt; rowsNum; i++){
				if (matrix[i].length !== firstRowLen){
					output = false;
					break;
				}
				// compare element by element
				for (j = 0; j &lt; firstRowLen; j++){
					if(matrix[i][j] !== firstRow[j]){
						output = false;
						break;
					}
				}
				// exit as well from outer loop if necessary
				if (!output){
					break;
				}
			}
		}
		return output;
	};

	/**
	 * Set the border of the table. It updates the properties 'attr' and 'style' of the instance:
	 * 1. in 'style' property, sets up the following properties: 'border-width', 'border-color' and 'border-style'
	 * 2. in 'attr' property, sets up 'border' property.
	 * Note that if after setting the border there is an assigment of 'style' or 'attr' property, then some info about the border might be overwritten.
	 * @method  setBorder
	 * @param   {Object}     borderInfo        Object containing 'width', 'color' and 'style' for the border to set.
	 * @default border-width is set to 1, border-color is set to #000000, border-style is set to solid.
	 * @return {void}
	 */
	this.setBorder = function(borderInfo){
		var bw, bc, bs;
		if (borderInfo === undefined){
			borderInfo = {'width': 1, 'color': '#000000', 'style': 'solid'};
		}
		bw = borderInfo.width || 1;
		bc = borderInfo.color || '#000000';
		bs = borderInfo.style || 'solid';

		this.style['border-width'] = bw;
		this.style['border-color'] = bc;
		this.style['border-style'] = bs;
		this.attr.border = bw;
	};

	/**
	 * Removes the border of the table. It updates the properties 'attr' and 'style' of the instance:
	 * 1. in 'style' property, deletes the properties: 'border-width', 'border-color' and sets up 'border-style' to 'none'
	 * 2. in 'attr' property, deletes 'border' property.
	 * @method  removeBorder
	 * @return {void}
	 */
	this.removeBorder = function(){
		if (this.style.hasOwnProperty('border-width')) {
			delete this.style['border-width'];
		}
		if (this.style.hasOwnProperty('border-color')) {
			delete this.style['border-color'];
		}
		this.style['border-style'] = 'none';

		if (this.attr.hasOwnProperty('border')) {
			delete this.attr.border;
		}
	};

	/**
	 * Returns true if the table is fragmented, and false otherwise. It takes table rows and call method
	 * `Row::onlyTableInside()` on each of them until first "false" is encountered.
	 * &lt;br />A table is a __framed table__ if all table rows have only one cell and this cell contains
	 * only one element that is a Table instance.
	 * @method     isFragmented
	 * @return     {Boolean}       true if the table is framed, and false otherwise
	 */
	this.isFragmented = function(){
		if (this.rowNum() === 0){
			return false;
		}
		return this.content.elements.every(function(row){
			return row.onlyTableInside();
		});
	};

	/**
	 * Gives true if all table rows have border around (that is, each row is nothing but a table with border)
	 * false otherwise. If at least one of the properties, corresponding to the "bogus" elements is set, then
	 * the table is considered as being framed and hence all its rows will be framed.
	 * @method isFramed
	 * @return {Boolean}     true, if all table rows have border around
	 */
	this.isFramed = function(){
		// if at least one of these properties is set, the table is considered as being framed.
		var propertyList = ['bogusRowStyle', 'bogusRowAttr', 'bogusCellStyle',
							'bogusCellAttr', 'bogusTableStyle', 'bogusTableAttr'],
			that = this;
		return propertyList.some(function(prop){
			return (that[prop] !== undefined) &amp;&amp;  that[prop];
		});
	};

	/**
	 * Resets bogus properties. After resetting those properties, the table becomes a table without frame.
	 * @method resetBogus
	 * @return {void}
	 */
	this.resetBogus = function(){
		var propertyList = ['bogusRowStyle', 'bogusRowAttr', 'bogusCellStyle',
							'bogusCellAttr', 'bogusTableStyle', 'bogusTableAttr'],
			propertyListLen = propertyList.length,
			i;
		for (i = 0; i &lt; propertyListLen; i++){
			if(this.hasOwnProperty(propertyList[i])){
				delete this[propertyList[i]];
			}
		}
	};

	/**
	 * Appends the style to the column. If the column exists, the method call `Row::appendStyleToCell()`
	 * on each of the table rows.
	 * @method appendStyleToCol
	 * @param  {Number}        colNum    column number to which the style is to be appended.
	 * @param  {Style|Object}  style     Style or Object to be appended
	 * @return {void}
	 */
	this.appendStyleToCol = function(colNum, style){
		var colNumInt = parseInt(colNum, 10),
			colLen = this.colNum(),
			rowLen = this.rowNum(),
			i;
		if (colNumInt === colNum &amp;&amp; colNum >= 0 &amp;&amp; colNum &lt; colLen) {
			for (i = 0; i &lt; rowLen; i++){
				this.getElem(i).appendStyleToCellAt(colNum, style);
			}
		} else {
			throw new Error('The column is not present!');
		}


	};

	/**
	 * Generates table-specific html code with corresponding attributes and styles.
	 * Creation of the row-related html of each row is delegated to `Row::toHtml()`
	 * @method toHtml
	 * @return {String}
	 */
	this.toHtml = function () {
		var prologue = '', epilogue = '', tableTag = 'table', rowTag = 'tr', cellTag = 'td',
			bogusRowAttr, bogusRowStyle, bogusCellAttr, bogusCellStyle, bogusTableAttr, bogusTableStyle,
			bogusRowHtml, bogusCellHtml, bogusTableHtml, tableAttr, tableStyle, tableHtml, i, rowsNumber;

		if (this.isFramed()){
			// some preliminaries for the framed tables
			bogusRowAttr    = this.bogusRowAttr    ? this.bogusRowAttr.toString() : '';
			bogusRowStyle   = Helper.sandwichWith('style="', this.bogusRowStyle.toString(), '"');
			bogusCellAttr   = this.bogusCellAttr   ? this.bogusCellAttr.toString() : '';
			bogusCellStyle  = Helper.sandwichWith('style="', this.bogusCellStyle.toString(), '"');
			bogusTableAttr  = this.bogusTableAttr  ? this.bogusTableAttr.toString() : '';
			bogusTableStyle = Helper.sandwichWith('style="', this.bogusTableStyle.toString(), '"');

			bogusRowHtml = Helper.sandwichWith('&lt;', [rowTag, bogusRowAttr, bogusRowStyle].concatDropSpaces(), '>');
			bogusCellHtml = Helper.sandwichWith('&lt;', [cellTag, bogusCellAttr, bogusCellStyle].concatDropSpaces(), '>');
			bogusTableHtml = Helper.sandwichWith('&lt;', [tableTag, bogusTableAttr, bogusTableStyle].concatDropSpaces(), '>');

			epilogue = bogusRowHtml + bogusCellHtml + bogusTableHtml;
			prologue = Helper.sandwichWith('&lt;/', tableTag, '>') + Helper.sandwichWith('&lt;/', cellTag, '>') + Helper.sandwichWith('&lt;/', rowTag, '>');
		}
		tableAttr  = this.attr  ? this.attr.toString() : '';
		tableStyle = Helper.sandwichWith('style="', this.style.toString(), '"');
		tableHtml  = Helper.sandwichWith('&lt;', [tableTag, tableAttr, tableStyle].concatDropSpaces(), '>');
		rowsNumber = this.rowNum();
		for (i = 0; i &lt; rowsNumber; i++) {
			tableHtml += epilogue;
			tableHtml += this.getElem(i).toHtml();
			tableHtml += prologue;
		}
		tableHtml += Helper.sandwichWith('&lt;/', tableTag, '>');
		return tableHtml;
	};

	/**
	 * Style of the row containing a single cell. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Style} bogusRowStyle
	 * @default  null
	 */
	this.bogusRowStyle = null; // new TableRowStyle();

	/**
	 * Attributes of the row containing a single cell. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusRowAttr
	 * @default  null
	 */
	this.bogusRowAttr = null; // new Attributes();

	/**
	 * Style of the  the cell which fills the whole row. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {TableCellStyle} bogusCellStyle
	 * @default  null
	 */
	this.bogusCellStyle = null; // new TableCellStyle();

	/**
	 * Attributes of the  the cell which fills the whole row. It is used to created to a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusCellAttr
	 * @default  null
	 */
	this.bogusCellAttr = null; // new Attributes();

	/**
	 * Style of the  the table that will be inserted into the single cell to create a table with framed lines.
	 * It is supposed that all properties
	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {TableStyle} bogusTableStyle
	 * @default  null
	 */
	this.bogusTableStyle = null; // new TableStyle();

	/**
	 * Attributes of the  the table that will be inserted into the single cell to create a table with framed lines.
 	 * It is supposed that all properties
 	 * bogusRowStyle, bogusRowAttr, bogusCellStyle, bogusCellAttr, bogusTableStyle, bogusTableAttr
	 * are simultaneously null or set.
	 * @property {Attribute} bogusTableAttr
	 * @default  null
	 */
	this.bogusTableAttr = null; // new Attributes();

	/**
	 * If the table is fragmented and all rows have the same requested property, then
	 * this property of the first row is returned. In any other case, null is returned.
	 * NB: to compare requested property for all rows, this property must be an object
	 * with boolean-valued method isTheSameAs().
	 * @method   getBogusRowProp
	 * @param    {String}         prop      a name of the property to return. All rows shiuld have this property.
	 * @return   {Object|null}			    the value of the property specified by the argument, if it is the same
	 *                                      for all rows, null otherwise.
	 */
	this.getBogusRowProp = function(prop){
		if (!this.isFragmented()){
			return null;
		}
		var firstRow = this.getFirst(),
			rowNum = this.rowNum(),
			rowProp, i, firstRowProp;
		if (firstRow.hasOwnProperty(prop)){
			firstRowProp = firstRow[prop];
		} else {
			return null;
		}
		if (rowNum === 1){
			return firstRowProp;
		}
		if (typeof firstRowProp.isTheSameAs !== 'function'){
			return null;
		}
		for (i = 1; i &lt; rowNum; i++){
			rowProp = this.getElem(i)[prop];
			if (!firstRowProp.isTheSameAs(rowProp)){
				return null;
			}
		}
		return firstRowProp;

	};


	/**
	 * If the table is fragmented and all the rows have the same styles, then this style is returned.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusRowProp('style')`.
	 * @method   getBogusRowStyle
	 * @return   {Style|null}
	 */
	this.getBogusRowStyle = function(){
		return this.getBogusRowProp('style');
	};

	/**
	 * If the table is fragmented and all the rows have the same styles, then this style is returned.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusRowProp('attr')`.
	 * @method   getBogusRowAttr
	 * @return   {Attributes|null}
	 */
	this.getBogusRowAttr = function(){
		return this.getBogusRowProp('attr');
	};

	/**
	 * If the table is fragmented, gives the requested property of the bogus cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method  getBogusCellProp
	 * @param  {String}      propName            requested property (supposed to be "style" or "attr")
	 * @return {Object|null}
	 */
	this.getBogusCellProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getBogusCellProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getBogusCellProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;
	};

	/**
	 * If the table is fragmented, returns the style of the bogus cell if it is the same for all cells.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusCellProp('style')`.
	 * @method   getBogusCellStyle
	 * @return   {Style|null}
	 */
	this.getBogusCellStyle = function(){
		return this.getBogusCellProp('style');
	};

	/**
	 * If the table is fragmented, returns the attributes of the bogus cell if it is the same for all cells.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusCellProp('attr')`.
	 * @method   getBogusCellAttr
	 * @return   {Attributes|null}
	 */
	this.getBogusCellAttr = function(){
		return this.getBogusCellProp('attr');
	};


	/**
	 * If the table is fragmented, gives the requested property of the bogus cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method  getBogusTableProp
	 * @param   {String}     propName            requested property (supposed to be "style" or "attr")
	 * @return  {Object|null}
	 */
	this.getBogusTableProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getBogusTableProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getBogusTableProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;

	};

	/**
	 * If the table is fragmented, returns the style of the bogus table if it is the same for all tables.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusTableProp('style')`.
	 * @method   getBogusTableStyle
	 * @return   {Style|null}
	 */
	this.getBogusTableStyle = function(){
		return this.getBogusTableProp('style');
	};

	/**
	 * If the table is fragmented, returns the attributes of the bogus table if it is the same for all tables.
	 * Otherwise, null is returned. This is an alias for `Table::getBogusTableProp('attr')`.
	 * @method   getBogusTableAttr
	 * @return   {Attributes|null}
	 */
	this.getBogusTableAttr = function(){
		return this.getBogusTableProp('attr');
	};


	/**
	 * If the table is fragmented, then sets up the bogus properties and rearrange content property.
	 * If not, the table remains as it is.
	 * @method   desintangle
	 * @return   {void}
	 */
	this.disentangle = function(){
		if (!this.isFragmented()){
			return null;
		}
		var newContent = new Content(),
			rowNum = this.rowNum(),
			i;
		this.bogusRowAttr = this.getBogusRowAttr();
		this.bogusRowStyle = this.getBogusRowStyle();
		this.bogusCellAttr = this.getBogusCellAttr();
		this.bogusCellStyle = this.getBogusCellStyle();
		this.bogusTableAttr = this.getBogusTableAttr();
		this.bogusTableStyle = this.getBogusTableStyle();
		for (i = 0; i &lt; rowNum; i++){
			newContent.appendElem(this.getElem(i).getFirst().getFirst().getFirst());
		}
		this.content = newContent;
	};


}
Table.prototype = Object.create(Tag.prototype);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Attributes.html">Attributes</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CKHelper.html">CKHelper</a></li><li><a href="Content.html">Content</a></li><li><a href="Helper.html">Helper</a></li><li><a href="ImageStyle.html">ImageStyle</a></li><li><a href="Link.html">Link</a></li><li><a href="LinkAttributes.html">LinkAttributes</a></li><li><a href="LinkStyle.html">LinkStyle</a></li><li><a href="List.html">List</a></li><li><a href="ListItem.html">ListItem</a></li><li><a href="ListItemStyle.html">ListItemStyle</a></li><li><a href="ListStyle.html">ListStyle</a></li><li><a href="Property.html">Property</a></li><li><a href="Row.html">Row</a></li><li><a href="StringHelper.html">StringHelper</a></li><li><a href="Style.html">Style</a></li><li><a href="Table.html">Table</a></li><li><a href="TableAttributes.html">TableAttributes</a></li><li><a href="TableCellStyle.html">TableCellStyle</a></li><li><a href="TableRowStyle.html">TableRowStyle</a></li><li><a href="TableStyle.html">TableStyle</a></li><li><a href="Tag.html">Tag</a></li><li><a href="Unit.html">Unit</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#appendCell">appendCell</a></li><li><a href="global.html#appendElem">appendElem</a></li><li><a href="global.html#appendElemIfNotEmpty">appendElemIfNotEmpty</a></li><li><a href="global.html#appendItem">appendItem</a></li><li><a href="global.html#appendList">appendList</a></li><li><a href="global.html#appendProperty">appendProperty</a></li><li><a href="global.html#appendRow">appendRow</a></li><li><a href="global.html#appendStyle">appendStyle</a></li><li><a href="global.html#appendStyleToCellAt">appendStyleToCellAt</a></li><li><a href="global.html#appendStyleToCol">appendStyleToCol</a></li><li><a href="global.html#appendStyleToElemAt">appendStyleToElemAt</a></li><li><a href="global.html#attr">attr</a></li><li><a href="global.html#attr[undefined]">attr[undefined]</a></li><li><a href="global.html#bogusCellAttr">bogusCellAttr</a></li><li><a href="global.html#bogusCellStyle">bogusCellStyle</a></li><li><a href="global.html#bogusRowAttr">bogusRowAttr</a></li><li><a href="global.html#bogusRowStyle">bogusRowStyle</a></li><li><a href="global.html#bogusTableAttr">bogusTableAttr</a></li><li><a href="global.html#bogusTableStyle">bogusTableStyle</a></li><li><a href="global.html#cellNum">cellNum</a></li><li><a href="global.html#cellpadding">cellpadding</a></li><li><a href="global.html#cellspacing">cellspacing</a></li><li><a href="global.html#colNum">colNum</a></li><li><a href="global.html#color">color</a></li><li><a href="global.html#columnWidths">columnWidths</a></li><li><a href="global.html#concatDropSpaces">concatDropSpaces</a></li><li><a href="global.html#content">content</a></li><li><a href="global.html#crack">crack</a></li><li><a href="global.html#createCellFromHtml">createCellFromHtml</a></li><li><a href="global.html#createLinkFromHtml">createLinkFromHtml</a></li><li><a href="global.html#createListFromHtml">createListFromHtml</a></li><li><a href="global.html#createListItemFromHtml">createListItemFromHtml</a></li><li><a href="global.html#createOlFromHtml">createOlFromHtml</a></li><li><a href="global.html#createRowFromHtml">createRowFromHtml</a></li><li><a href="global.html#createTableFromHtml">createTableFromHtml</a></li><li><a href="global.html#createTagFromHtml">createTagFromHtml</a></li><li><a href="global.html#createUlFromHtml">createUlFromHtml</a></li><li><a href="global.html#desintangle">desintangle</a></li><li><a href="global.html#dropCell">dropCell</a></li><li><a href="global.html#dropCellAt">dropCellAt</a></li><li><a href="global.html#dropColAt">dropColAt</a></li><li><a href="global.html#dropColumn">dropColumn</a></li><li><a href="global.html#dropElemAt">dropElemAt</a></li><li><a href="global.html#dropFirst">dropFirst</a></li><li><a href="global.html#dropLast">dropLast</a></li><li><a href="global.html#dropProtocol">dropProtocol</a></li><li><a href="global.html#dropRow">dropRow</a></li><li><a href="global.html#elements">elements</a></li><li><a href="global.html#fileExt">fileExt</a></li><li><a href="global.html#findAscendant">findAscendant</a></li><li><a href="global.html#firstLetterUpperCase">firstLetterUpperCase</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#getBogusCellAttr">getBogusCellAttr</a></li><li><a href="global.html#getBogusCellProp">getBogusCellProp</a></li><li><a href="global.html#getBogusCellStyle">getBogusCellStyle</a></li><li><a href="global.html#getBogusRowAttr">getBogusRowAttr</a></li><li><a href="global.html#getBogusRowProp">getBogusRowProp</a></li><li><a href="global.html#getBogusRowStyle">getBogusRowStyle</a></li><li><a href="global.html#getBogusTableAttr">getBogusTableAttr</a></li><li><a href="global.html#getBogusTableProp">getBogusTableProp</a></li><li><a href="global.html#getBogusTableStyle">getBogusTableStyle</a></li><li><a href="global.html#getBorderInfo">getBorderInfo</a></li><li><a href="global.html#getCellWidths">getCellWidths</a></li><li><a href="global.html#getElem">getElem</a></li><li><a href="global.html#getFirst">getFirst</a></li><li><a href="global.html#getHref">getHref</a></li><li><a href="global.html#getLast">getLast</a></li><li><a href="global.html#getMatrix">getMatrix</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getProfile">getProfile</a></li><li><a href="global.html#getStyleProp">getStyleProp</a></li><li><a href="global.html#getWidth">getWidth</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#href">href</a></li><li><a href="global.html#insertCellAt">insertCellAt</a></li><li><a href="global.html#insertColAt">insertColAt</a></li><li><a href="global.html#insertColumn">insertColumn</a></li><li><a href="global.html#insertColumnAt">insertColumnAt</a></li><li><a href="global.html#insertElemAt">insertElemAt</a></li><li><a href="global.html#insertRow">insertRow</a></li><li><a href="global.html#isElemEmpty">isElemEmpty</a></li><li><a href="global.html#isEmpty">isEmpty</a></li><li><a href="global.html#isertItemAt">isertItemAt</a></li><li><a href="global.html#isFragmented">isFragmented</a></li><li><a href="global.html#isFramed">isFramed</a></li><li><a href="global.html#isLikeAs">isLikeAs</a></li><li><a href="global.html#isSameWidth">isSameWidth</a></li><li><a href="global.html#isTheSameAs">isTheSameAs</a></li><li><a href="global.html#itemNum">itemNum</a></li><li><a href="global.html#knockOutCell">knockOutCell</a></li><li><a href="global.html#knockOutCol">knockOutCol</a></li><li><a href="global.html#length">length</a></li><li><a href="global.html#loadFromHtml">loadFromHtml</a></li><li><a href="global.html#margin">margin</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nodeOffsetString">nodeOffsetString</a></li><li><a href="global.html#nodeString">nodeString</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#onlyFirstLetterUpperCase">onlyFirstLetterUpperCase</a></li><li><a href="global.html#onlyTableInside">onlyTableInside</a></li><li><a href="global.html#padding">padding</a></li><li><a href="global.html#propNum">propNum</a></li><li><a href="global.html#removeBorder">removeBorder</a></li><li><a href="global.html#resetBogus">resetBogus</a></li><li><a href="global.html#roundUp">roundUp</a></li><li><a href="global.html#rowNum">rowNum</a></li><li><a href="global.html#sandwichWith">sandwichWith</a></li><li><a href="global.html#sanitize">sanitize</a></li><li><a href="global.html#setAttr">setAttr</a></li><li><a href="global.html#setBorder">setBorder</a></li><li><a href="global.html#setCellWidths">setCellWidths</a></li><li><a href="global.html#setHref">setHref</a></li><li><a href="global.html#setName">setName</a></li><li><a href="global.html#setProfile">setProfile</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setWidth">setWidth</a></li><li><a href="global.html#specialChar">specialChar</a></li><li><a href="global.html#splitWeighted">splitWeighted</a></li><li><a href="global.html#str">str</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#sub">sub</a></li><li><a href="global.html#toHtml">toHtml</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#toText">toText</a></li><li><a href="global.html#trace">trace</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#validateWidth">validateWidth</a></li><li><a href="global.html#width">width</a></li><li></li><li></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha4</a> on Fri Mar 07 2014 12:35:59 GMT+0100 (ora solare Europa occidentale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
