<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\classes\CKHelper\Selection.js - Newsletter API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..\logo.png" title="Newsletter API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Attributes.html">Attributes</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/CellProperties.html">CellProperties</a></li>
            
                <li><a href="../classes/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../classes/CLink.html">CLink</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/CTable.html">CTable</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/Factory.html">Factory</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/ImageProperties.html">ImageProperties</a></li>
            
                <li><a href="../classes/ImageStyle.html">ImageStyle</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/LinkAttributes.html">LinkAttributes</a></li>
            
                <li><a href="../classes/LinkProperties.html">LinkProperties</a></li>
            
                <li><a href="../classes/LinkStyles.html">LinkStyles</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemProperties.html">ListItemProperties</a></li>
            
                <li><a href="../classes/ListItemStyles.html">ListItemStyles</a></li>
            
                <li><a href="../classes/ListProperties.html">ListProperties</a></li>
            
                <li><a href="../classes/ListStyles.html">ListStyles</a></li>
            
                <li><a href="../classes/Mapping.html">Mapping</a></li>
            
                <li><a href="../classes/OList.html">OList</a></li>
            
                <li><a href="../classes/PlainText.html">PlainText</a></li>
            
                <li><a href="../classes/Properties.html">Properties</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/RowProperties.html">RowProperties</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/StringHelper.html">StringHelper</a></li>
            
                <li><a href="../classes/Styles.html">Styles</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/TableAttributes.html">TableAttributes</a></li>
            
                <li><a href="../classes/TableCellStyles.html">TableCellStyles</a></li>
            
                <li><a href="../classes/TableProperties.html">TableProperties</a></li>
            
                <li><a href="../classes/TableRowStyles.html">TableRowStyles</a></li>
            
                <li><a href="../classes/TableStyles.html">TableStyles</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/UList.html">UList</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../modules/Controllers.html">Controllers</a></li>
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Properties.html">Properties</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\classes\CKHelper\Selection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint plusplus: true, white: true */
/*global DOMParser, CKHelper, CKEDITOR, Node, Styles, Dom */

/**
* Represents selected elements in the editor window. The argument &#x60;ed&#x60; is a
* [CKEditor editor](http://docs.ckeditor.com/#!/api/CKEDITOR.editor &quot;see official site&quot;)  instance.
* @module              CKHelper
* @class               Selection
* @param               {CKEDITOR.editor}         ed
*/
function Selection(ed) {
    &quot;use strict&quot;;
    if (!(this instanceof Selection)) {
        return new Selection(ed);
    }
    if (ed !== undefined &amp;&amp; !(ed instanceof CKEDITOR.editor)){
        throw new Error(&#x27;The first argument must be a CKEDITOR.editor instance!&#x27;);
    }

    /**
    * Editor instance containing the selection.
    * @property        {CKEDITOR.editor}         editor
    * @private
    */
    var editor = ed;

    /**
    * Selected elements.
    * @property        {CKEDITOR.dom.selection}  selected
    * @private
    */
    var selected;
    if (editor instanceof CKEDITOR.editor){
        selected = editor.getSelection();
    }

    /**
    * Array of [range instances](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.range) corresponding to the selection.
    * @property {Array}   ranges
    * @private
    */
    var ranges;
    if (selected instanceof CKEDITOR.dom.selection){
        ranges = selected.getRanges();
    }

    /**
     * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}} getter.
     * @method         getRanges
     * @return         {Array}          array of CKEDITOR.dom.range instances
     */
    this.getRanges = function(){
        return ranges;
    };

    /**
     * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} setter. Sets as well
     * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}}.
     * @method         setSelected
     * @return         {void}
     */
    this.setSelected = function(obj){
        if (!(obj instanceof CKEDITOR.dom.selection)){
            throw new Error(&#x27;The argument must be a CKEDITOR.dom.selection instance!&#x27;);
        }
        selected = obj;
        ranges = selected.getRanges();
    };

    /**
     * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} getter.
     * @method         getSelected
     * @return         {CKEDITOR.dom.selection}
     * @private
     */
    this.getSelected = function(){
        return selected;
    };


    /**
     * {{#crossLink &quot;Selection/editor:property&quot;}}editor{{/crossLink}} getter.
     * @method         getEditor
     * @return         {CKEDITOR.editor}
     */
    this.getEditor = function(){
        return editor;
    };

    /**
     * {{#crossLink &quot;Selection/editor:property&quot;}}editor{{/crossLink}} setter. Sets as well
     * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} and
     * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}}.
     * @method        setEditor
     * @param         {CKEDITOR.editor}     obj
     */
    this.setEditor = function(obj){
        if (!(obj instanceof CKEDITOR.editor)){
            throw new Error(&#x27;The argument must be a CKEDITOR.editor instance!&#x27;);
        }
        editor = obj;
        selected = obj.getSelection();
        ranges = (selected instanceof CKEDITOR.dom.selection) ? selected.getRanges() : null;
    };

    /**
    * If selection is empty, returns empty array. Otherwise returns two dimensional array of the form
    * &lt;pre&gt;
    * [[a&lt;sub&gt;00&lt;/sub&gt;, a&lt;sub&gt;01&lt;/sub&gt;, ...], [a&lt;sub&gt;10&lt;/sub&gt;, a&lt;sub&gt;11&lt;/sub&gt;, ...], ...].
    * &lt;/pre&gt;
    * Each inner array corresponds to the elements inside the
    * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}} property of the selection.
    * Since DOM is an ***ordered*** collection of the nodes, the the above mentioned array is
    * just a collection of simply-connected sets of nodes corresponding to the selection.
    *
    * NB1: _Simply-connected_ set is a set such that there exists a path inside the set
    * connecting two arbitrary elements of the set.
    *
    * NB2: _Path_ consists of pieces connecting two neighbours (the set is ordered, so that
    * the concept of &quot;neighbour&quot; exists).
    * @method          selectedNodes
    * @param           {Selection}          sel
    * @private
    * @return          {Array}              two dimensional array of
    *                                       [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
    *                                       or empty array
    */
    var selectedNodes = function(sel){
        var startContainer, endContainer,
            startOffset, endOffset,
            rangesLocal = sel.getRanges(),
            range, startChild, endChild, nextChild,
            lastBlock = [],
            firstBlock = [],
            middleBlock = [],
            startElem, endElem,
            startType, endType,
            i, rangesLen, commonAnc,
            selNodes = [],      // container for all sel nodes
            rangeNodes;         // container for sel nodes in current range
        if (rangesLocal){
            rangesLen = rangesLocal.length;
            for (i = 0; i &lt; rangesLen; i++){
                // console.info(&#x27;loop&#x27;, i);
                rangeNodes = [];
                range = rangesLocal[i];
                if (!range.collapsed) {
                    startContainer = range.startContainer;
                    endContainer = range.endContainer;
                    startType = startContainer.type;
                    endType   = endContainer.type;
                    startOffset = range.startOffset;
                    endOffset = range.endOffset;
                    startElem = null;
                    endElem = null;
                    lastBlock = [];
                    firstBlock = [];
                    middleBlock = [];

                    if (startContainer.equals(endContainer)){
                        // console.log(&#x27;start = end&#x27;);
                        if (startType === CKEDITOR.NODE_TEXT){
                            startElem = startContainer.split(startOffset).split(endOffset - startOffset).getPrevious();
                            endElem = startElem;
                        } else if (startType === CKEDITOR.NODE_ELEMENT){
                            startElem = startContainer.getChild(startOffset);
                            // endElem = startContainer.getChild(endOffset) || startElem;
                            endElem = startElem;
                        }
                    } else {
                        if (endType === CKEDITOR.NODE_TEXT){
                            endElem = endContainer.getLength() === endOffset ? endContainer : endContainer.split(endOffset).getPrevious();
                        } else if (endType === CKEDITOR.NODE_ELEMENT){
                            if (endOffset &gt; 0){
                                endElem = endContainer.getChild(endOffset - 1);
                            } else {
                                endElem = endContainer.getParent();
                            }
                        }
                        if (startType === CKEDITOR.NODE_TEXT){
                            // Do not split the element if its length is equal to offset.
                            // In this case, take the next sibling of the element.
                            startElem = startContainer.getLength() === startOffset ? startContainer.getNext() : startContainer.split(startOffset);
                            // startElem =  startContainer.split(startOffset);
                        } else if (startType === CKEDITOR.NODE_ELEMENT){
                            startElem = startContainer.getChild(startOffset);
                        }

                    }
                    if (startElem === null || endElem === null){
                        // console.log(&#x27;start elem or end elem is null: &#x27;, startElem, endElem);
                        break;
                    }
                    // console.log(&#x27;start elem: &#x27;, startElem, &#x27;, end elem: &#x27;, endElem);
                    if (CKHelper.containsOrEqual(startElem, endElem)){
                        rangeNodes = [startElem];
                    } else if (CKHelper.containsOrEqual(endElem, startElem)) {
                        rangeNodes = [endElem];
                    } else {
                        commonAnc = startElem.getCommonAncestor(endElem);
                        startChild = CKHelper.childWithNode(commonAnc, startElem);
                        endChild = CKHelper.childWithNode(commonAnc, endElem);

                        firstBlock = startElem.getParent().equals(commonAnc) ? [startElem] : CKHelper[&#x27;bunch-next-siblings&#x27;](startElem, startChild);
                        // console.log(&#x27;firstBlock: &#x27;, firstBlock);
                        rangeNodes = rangeNodes.concat(firstBlock);
                        // console.log(&#x27;rangeNodes after adding first block: &#x27;, rangeNodes.length, &#x27;, &#x27;, rangeNodes);
                        nextChild = startChild.getNext();
                        while(nextChild &amp;&amp; !nextChild.equals(endChild)){
                            // console.log(&#x27;pushing nextChild: &#x27;, nextChild);
                            middleBlock.push(nextChild);
                            nextChild = nextChild.getNext();
                        }
                        // console.log(&#x27;middleBlock: &#x27;, middleBlock);
                        rangeNodes = rangeNodes.concat(middleBlock);

                        lastBlock = endElem.getParent().equals(commonAnc) ? [endElem] : CKHelper[&#x27;bunch-prev-siblings&#x27;](endElem, endChild);

                        // console.log(&#x27;lastBlock: &#x27;, lastBlock);
                        rangeNodes = rangeNodes.concat(lastBlock.reverse());
                        // console.log(&#x27;rangeNodes after adding end block: &#x27;, rangeNodes.length, &#x27;, &#x27;, rangeNodes);
                    }

                }
                // console.log(&#x27;rangeNodes that are to be pushed into selNodes: &#x27;, rangeNodes);
                selNodes.push(rangeNodes);
            }


        }
        // selNodes.forEach(function(elem, ind){
        //     elem.forEach(function(elem2, ind2){
        //         console.log(ind, ind2, elem2);
        //     });
        // });
        return selNodes;
    };

    /**
     * Two-dimensional array of nodes in selection.
     *
     * This property was created in order to assure that private method
     * {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} gets called
     * just once because it seemingly modifies DOM in such
     * a way that if one calles it multiple times, a wrong array offset is requested, hence, an
     * error is generated.
     * @property       {Array}      nodes
     * @type           {Array}      array of [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
     */
    this.nodes = selectedNodes(this);

    /**
     * Returns text representation of the selected nodes. Remember that they are located inside a two-dimensional array.
     *
     * @method    toText
     * @param     {String}    blockSeparator          string to be used as a separator between arrays
     * @param     {String}    elemSeparator           string to be used as a separator between elements in array
     * @return    {String}
     */
    this.toText = function(blockSeparator, elemSeparator){
        var total = [];
        blockSeparator = blockSeparator || &#x27; &#x27;;
        elemSeparator = elemSeparator || &#x27; &#x27;;
        this.nodes.forEach(function(arr){
            var arrayNested = [];
            arr.forEach(function(el){
                if (el.type === CKEDITOR.NODE_TEXT || el.type === CKEDITOR.NODE_ELEMENT){
                    arrayNested.push(el.getText());
                }
            });
            total.push(arrayNested.join(elemSeparator));
        });
        return total.join(blockSeparator);
    };


    /**
     * Returns the start element of selection if it exists.
     * @method         getStartElement
     * @return         {CKEDITOR.dom.element}
     */
    this.getStartElement = function(){
        var sel = this.getSelected();
        if (sel instanceof CKEDITOR.dom.selection){
            return sel.getStartElement();
        }
    };

    /**
     * Returns &#x60;true&#x60; if {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} is empty,
     * &#x60;false&#x60; otherwise.
     *
     * {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} output is considered empty
     * if it is either empty array &#x60;[]&#x60; or an array containing empty array: &#x60;[[]]&#x60;.
     * @method         isEmpty
     * @return         {Boolean}
     */
    this.isEmpty = function(){
        var s = this.nodes;
        // console.log(&#x27;selected nodes&#x27;  , s);
        //    empty array []  or containing empty array [[]]
        return s.length === 0 || (s.length === 1 &amp;&amp; s[0].length === 0);
    };


    /**
     * Returns &#x60;true&#x60; if selected text starts inside a link, &#x60;false&#x60; otherwise.
     * In case when the selection is empty, cursor position is considered as beginning
     * of empty selection.
     * @method         startsInsideLink
     * @return         {Boolean}            whether the selection starts inside a link
     */
    this.startsInsideLink = function(){
        var start = this.getStartElement(),
            parentLink = null;
        if (start !== undefined &amp;&amp; start !== null &amp;&amp; (typeof start.getAscendant === &#x27;function&#x27;)){
            parentLink = start.getAscendant(&#x27;a&#x27;, true);
        }
        return parentLink !== null;
    };


    /**
     * Returns &#x60;true&#x60; if selection content is editable, &#x60;false&#x60; otherwise.
     *
     * Selection is editable if:
     * &lt;ol&gt;
     * &lt;li&gt;it is empty&lt;/li&gt;
     * &lt;li&gt;it contains a single element that has type &#x60;text&#x60;&lt;/li&gt;
     * &lt;li&gt;it contains a single element that is a link which child nodes are of type &#x60;text&#x60;&lt;/li&gt;
     * &lt;/ol&gt;
     * @method         isEditable
     * @return         {Boolean}
     */
    this.isEditable = function(){
        var nodes = this.nodes;
        if (!nodes){
            // console.log(&#x27;nodes are not defined&#x27;);
            return true;
        }
        var len = nodes.length;
        // exit point if the nodes array length differs form one
        if (len !== 1){
            // return true if it is empty and false if it is too long
            return len === 0;
        }

        // the first (and the only) block of the selection
        var firstBlock = nodes[0];
        len = firstBlock.length;
        // exit point if the firstblock is empty or has more than one element
        if (len !== 1){
            // return true if it is empty and false if it is too long
            return len === 0;
        }

        // the only element
        var elem = firstBlock[0];
        if (elem.type === CKEDITOR.NODE_TEXT){
            return true;
        }
        if (elem.type === CKEDITOR.NODE_ELEMENT){
            if (elem.getName() === &#x27;a&#x27;){
                len = elem.getChildCount();
                if (len !== 1){
                    return len === 0;
                }
                return elem.getChild(0).type === CKEDITOR.NODE_TEXT;
            }
            return false;
        }
        return false;

    };

    /**
     * Removes duplicate DOM nodes form input array. Each element of the array must be an instance of
     * [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject).
     * @method         dropDuplicates
     * @private
     * @param          {Array}              $arr    one-dimensional array of
     *                                              [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
     *                                              objects
     * @return         {Array}                      array of distinct
     *                                              [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
     *                                              elements
     */
    var dropDuplicates = function(arr){
        var len = arr.length;
        if (len === 0 || len === 1){
            return arr;
        }
        if (len &gt; 1){
            var first = arr[0],
                output = [],
                outputLen = 0,
                i, j,
                isPresent;
            output.push(first);
            outputLen++;

            for (i = 1; i &lt; len; i++){
                isPresent = false;
                for (j = 0; j &lt; outputLen; j++){
                    if (output[j].equals(arr[i])){
                        isPresent = true;
                        break;
                    }
                }
                if (!isPresent){
                    output.push(arr[i]);
                    outputLen++;
                }
            }
            return output;
        }
    };

    /**
     * Replaces each element in {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} by
     * a link in which this element is located. In case the element is not located inside any link, then it
     * is leaved without changes. The output array mimics the structure of
     * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} array: it should be a two-dimensional array
     * without duplicates.
     * @method         absorbLink
     * @return         {void}
     */
    this.absorbLink = function(){
        var input = this.nodes,
            output = [],
            temp, link;
        if (this.isEmpty()){
            // if the selection is empty and the cursor is inside a link,
            // insert this link into nodes
            link = this.getStartElement().getAscendant(&#x27;a&#x27;, true);
            if (link){
                output.push([link]);   // resulting array must be 2-dimensional with a single element
            }
        } else {
            // parse elements in the selectionif it is not empty
            input.forEach(function(block){
                if (Array.isArray(block) &amp;&amp; block.length &gt; 0){
                    temp = [];
                    block.forEach(function(elem){
                        link = elem.getAscendant(&#x27;a&#x27;, true);
                        temp.push(link || elem) ;
                    });
                    output.push(dropDuplicates(temp));
                }
            });

        }
        this.nodes = output;
    };

    /**
     * Propagate style property named &#x60;prop&#x60; with the value &#x60;val&#x60; to the last descendant of each node in the selection.
     * Remember that the selection is in general a two-dimensional array (or one-dimensional if the selection is empty).
     * @method         switchDeepestChildStyle
     * @param          String               prop        name of the property to be imposed
     * @param          String               val         on-value of the above property
     * @param          String               altVal      off-value of the property
     * @since          0.0.4
     * @return         void
     */
    this.switchDeepestChildStyle = function(prop, val, altVal){
        this.nodes.forEach(function(line){
            var dom = new Dom();
            if (line){
                line.forEach(function(node){
                    dom.nailStyleProperty(node.$, prop, val, altVal);
                });
            }
        });
    };



}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
