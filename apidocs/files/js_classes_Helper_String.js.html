<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\classes\Helper\String.js - Newsletter API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..\logo.png" title="Newsletter API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Attributes.html">Attributes</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/Factory.html">Factory</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/ImageStyle.html">ImageStyle</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/LinkAttributes.html">LinkAttributes</a></li>
            
                <li><a href="../classes/LinkStyles.html">LinkStyles</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemStyles.html">ListItemStyles</a></li>
            
                <li><a href="../classes/ListStyles.html">ListStyles</a></li>
            
                <li><a href="../classes/Mapping.html">Mapping</a></li>
            
                <li><a href="../classes/OList.html">OList</a></li>
            
                <li><a href="../classes/PlainText.html">PlainText</a></li>
            
                <li><a href="../classes/Properties.html">Properties</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/StringHelper.html">StringHelper</a></li>
            
                <li><a href="../classes/Styles.html">Styles</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/TableAttributes.html">TableAttributes</a></li>
            
                <li><a href="../classes/TableCellStyles.html">TableCellStyles</a></li>
            
                <li><a href="../classes/TableRowStyles.html">TableRowStyles</a></li>
            
                <li><a href="../classes/TableStyles.html">TableStyles</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/UList.html">UList</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Properties.html">Properties</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\classes\Helper\String.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global  DOMParser, Node, Helper, Attributes, Styles, Cell, TableRowStyle, Row, ListItem, Table,
          Content, Tag, List, Link, LinkStyles, LinkAttributes */


/**
 * These are methods to convert strings into different objects.
 * @module  Helper
 * @class  StringHelper
 * @since  0.0.1
 * @author A.Shcherbakov
 */
String.prototype.createCellFromHtml = function(){
    /**
     * Transforms a cell-html string into Cell object. It is supposed that the string to process is of the
     * following form: &#x60;&lt;td ... &gt; ... &lt;/td&gt;&#x60;. Inside the tag, there might be other nodes. If they are recognized
     * as a &quot;supported&quot; ones, the corresponding functions will be called to transform them into objects.
     * @method  createCellFromHtml
     * @return  {Cell|null}
     */
    var htmlStr = this,
        parser = new DOMParser(),
        fullTable = &#x27;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&#x27; + htmlStr + &#x27;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#x27;,
        doc = parser.parseFromString(fullTable, &#x27;text/html&#x27;),
        node = doc.getElementsByTagName(&#x27;td&#x27;),
        cell, attrs, nodeStyle, cellContent;
    if (node.length === 0){
        return null;
    }
    // process the first cell in the list of cells. The remaining cells are to be processed
    // at their turn (when the cell becomes first)
    node = node[0];

    // creating object
    cell = new Cell();

    // imposing its styles
    nodeStyle = node.getAttribute(&#x27;style&#x27;);
    cell.setStyles(new Styles(nodeStyle));

    // imposing its attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty(&#x27;style&#x27;)){
        delete attrs.style;
    }
    cell.setAttributes(new Attributes(attrs));

    cellContent = node.innerHTML.inflate();
    cell.setContent(cellContent);
    return cell;
};

String.prototype.createRowFromHtml = function(){
    /**
     * Transforms a row-html string into a Row object. It is supposed that the string to process is of the
     * following form: &lt;tr ... &gt; ... &lt;/tr&gt;. Inside the tag, there might be elements &quot;td&quot; that will be
     * processed one by one by function String::createCellFromHtml().
     * @method  createRowFromHtml
     * @return  {Object} Row
     */
	var htmlStr = this,
		parser = new DOMParser(),
		fullTable  = &#x27;&lt;table&gt;&lt;tbody&gt;&#x27; + htmlStr + &#x27;&lt;/tbody&gt;&lt;/table&gt;&#x27;,
		doc = parser.parseFromString(fullTable, &#x27;text/html&#x27;),
		node = doc.getElementsByTagName(&#x27;tr&#x27;),
        row = new Row(),
		attrs, i, nodeStyle, cellsNum, currentCell,
        // row = new Row(),
        cell, cells;
	if (node.length === 0){
		return null;
	}
	// the first table row is to be processed. The remaining ones will be processed at thier turn.
	node = node[0];

	// imposing styles
	nodeStyle = node.getAttribute(&#x27;style&#x27;);
	row.setStyles(new Styles(nodeStyle));

	// imposing its attributes
	attrs = Helper.flatten(node.attributes);
	if (attrs.hasOwnProperty(&#x27;style&#x27;)){
		delete attrs.style;
	}
	row.setAttributes(new Attributes(attrs));

	cells = node.children;
	cellsNum = cells.length;
	for (i = 0; i &lt; cellsNum; i++){
		currentCell = cells[i];
		if (currentCell.tagName === &quot;TD&quot;){
			cell = currentCell.outerHTML.createCellFromHtml();
			row.appendCell(cell);
		}
	}
	return row;
};

String.prototype.createTableFromHtml = function(){
    /**
     * Creates an object representation from a string that is an html repersentation of a table.
     * Only one table is supposed to be processed at a time, so the string to be processed is to
     * be of the following form &#x60;&lt;table ...&gt; ... &lt;/table&gt;&#x60;. Inside the tag, there should be tags &quot;tr&quot;
     * that will be processed one by one by function String::createRowFromHtml().
     * @method         createTableFromHtml
     * @return         {Table|null}
     * @deprecated     Use Factory.mimic() method
     */
    console.info(&#x27;!&#x27;, &#x27;Method createTableFromHtml is deprecated! Use Factory.mimic() method.&#x27;);
    var htmlStr = this,
        parser = new DOMParser(),
        doc = parser.parseFromString(htmlStr, &#x27;text/html&#x27;),
        node = doc.getElementsByTagName(&#x27;table&#x27;),
        table, attrs, i, nodeStyle, rows, rowsNum, currentRow, row;
    if (node.length === 0){
        return null;
    }
    node = node[0];

    // creating table
    table = new Table();

    // imposing table styles
    nodeStyle = node.getAttribute(&#x27;style&#x27;);
    table.setStyles(new Styles(nodeStyle));
    // imposing table attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty(&#x27;style&#x27;)){
        delete attrs.style;
    }
    table.setAttributes(new Attributes(attrs));

    // the only child of the table is always tbody
    if (node.children.length !== 1){
        return table;
    }
    rows = node.children[0].children;
    rowsNum = rows.length;

    for (i = 0; i &lt; rowsNum; i++){
        currentRow = rows[i];
        if (currentRow.tagName === &quot;TR&quot;){
            row = currentRow.outerHTML.createRowFromHtml();
            table.appendRow(row);
        }
    }
    // if the table turns out to be framed, &quot;disentanlement&quot; will pull out properties of
    // bogus cells, rows and tables
    table.disentangle();
    return table;
};

String.prototype.createListFromHtml = function(listType){
    /**
     * Transforms a list string into a List object. The argument listType is used to initialize the
     * property &quot;name&quot; of the returned instance. If it is not provided, that the node tag-name property is used.
     * It is supposed that the string to process is of the following form:
     * &#x60;&lt;ol ... &gt; ... &lt;/ol&gt;&#x60; or &#x60;&lt;ul ... &gt; ... &lt;/ul&gt;&#x60;.
     * Inside the tag, there might be other nodes. If they are recognized as a &quot;supported&quot; ones, the
     * corresponding functions will be called to transform them into objects.
     * @method   createListFromHtml
     * @param    {String}           listType: ul or li
     * @return   {List|null}
     */
    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, &#x27;fakeId&#x27;),
        doc = parser.parseFromString(&#x27;&lt;div id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + str + &#x27;&lt;/div&gt;&#x27;, &#x27;text/html&#x27;),
        output = new List(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        nodeHtml, methodName, methodExists;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        output.setTag(listType || node.nodeName.toLowerCase());

        style = node.getAttribute(&#x27;style&#x27;);
        output.setStyles(new Styles(style));
        attrs = Helper.flatten(node.attributes);
        if (attrs.hasOwnProperty(&#x27;style&#x27;)){
            delete attrs.style;
        }
        output.setAttributes(new Attributes(attrs));
        // split the target string on blocks
        children = node.childNodes;
        childrenLen = children.length;
        for(i = 0; i &lt; childrenLen; i++){
            nodeInternal = children[i];
            // parsing only list item nodes
            if (nodeInternal.nodeType === Node.ELEMENT_NODE &amp;&amp; nodeInternal.nodeName === &#x27;LI&#x27;){
               nodeHtml = nodeInternal.outerHTML;
               methodName = &#x27;createListItemFromHtml&#x27;;
               methodExists = (typeof nodeHtml[methodName]) === &#x27;function&#x27;;
               elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
               output.appendElem(elem);
            }
        }
    }
    return output;
};

String.prototype.createUlFromHtml = function(){
    /**
     * Calls String::createListFromHtml(&#x27;ul&#x27;) on the target string.
     * @method  createUlFromHtml
     * @return  {List|null}
     */

    return this.toString().createListFromHtml(&#x27;ul&#x27;);
};

String.prototype.createOlFromHtml = function(){
    /**
     * Calls String::createListFromHtml(&#x27;ol&#x27;) on the target string.
     * @method  createOlFromHtml
     * @return  {List|null}
     */
    return this.toString().createListFromHtml(&#x27;ol&#x27;);
};

String.prototype.createListItemFromHtml = function(){
    /**
     * Transforms a list item string into a ListItem object. It is supposed that the string to process is of the
     * following form: &#x60;&lt;li ... &gt; ... &lt;/li&gt;&#x60;. Inside the tag, there might be other nodes. If they are recognized
     * as a &quot;supported&quot; ones, the corresponding functions will be called to transform them into objects.
     * @method  createListItemFromHtml
     * @return  {ListItem|null}
     */
    var htmlStr = this,
        parser = new DOMParser(),
        doc = parser.parseFromString(&#x27;&lt;ul&gt;&#x27; + htmlStr + &#x27;&lt;/ul&gt;&#x27;, &#x27;text/html&#x27;),
        node = doc.getElementsByTagName(&#x27;li&#x27;),
        listItem, attrs, i, nodeStyle, elem, elems, elemsNum, currentElem, methodToCall, methodExists, nodeName;
    if (node.length === 0){
        return null;
    }
    // process the first element among the found ones. The remaining elements
    // are to be processed at their turn (when each of the becomes first)
    node = node[0];

    // creating object
    listItem = new ListItem();

    // imposing its styles
    nodeStyle = node.getAttribute(&#x27;style&#x27;);
    listItem.setStyles(new Styles(nodeStyle));

    // imposing its attributes
    attrs = Helper.flatten(node.attributes);
    if (attrs.hasOwnProperty(&#x27;style&#x27;)){
        delete attrs.style;
    }
    listItem.setAttributes(new Attributes(attrs));
    elems = node.childNodes;
    elemsNum = elems.length;
    for (i = 0; i &lt; elemsNum; i++){
        currentElem = elems[i];
        switch (currentElem.nodeType){
            case Node.TEXT_NODE:
                elem = currentElem.textContent;
                break;
            case Node.ELEMENT_NODE:
                nodeName = currentElem.nodeName;
                methodToCall = &#x27;create&#x27; + Helper.onlyFirstLetterUpperCase(nodeName) + &#x27;FromHtml&#x27;;
                methodExists = String.prototype.hasOwnProperty(methodToCall);
                elem = methodExists ? currentElem.outerHTML[methodToCall]() : currentElem.outerHTML.createTagFromHtml();
                // console.log(&#x27;inside ListItem: methodToCall: &#x27;, methodToCall, &#x27; methodExists: &#x27;, methodExists);
                break;
            default:
                elem = currentElem.nodeValue;
        }
        listItem.appendElem(elem);
    }
    return listItem;
};

String.prototype.createTagFromHtml = function(){
    /**
     * Creates an instance of Tag class and fills in its property &quot;elements&quot; with
     * the elements recognized inside the string. It is supposed that the string is of the
     * form &#x60;&lt;tag [tag-attributes] [style=&quot;...&quot;]&gt;....&lt;/tag&gt;&#x60;.
     * @method    createTagFromHtml
     * @return    {Content|null}
     */

    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, &#x27;fakeId&#x27;),
        doc = parser.parseFromString(&#x27;&lt;div id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + str + &#x27;&lt;/div&gt;&#x27;, &#x27;text/html&#x27;),
        output = new Tag(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        tagName, nodeHtml, methodName, methodExists;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        if (node.nodeType === Node.ELEMENT_NODE){
            tagName = node.nodeName;
            output.setTag(tagName.toLowerCase());

            style = node.getAttribute(&#x27;style&#x27;);
            output.setStyles(new Styles(style));
            attrs = Helper.flatten(node.attributes);
            if (attrs.hasOwnProperty(&#x27;style&#x27;)){
                delete attrs.style;
            }
            output.setAttributes(new Attributes(attrs));
            // split the target string on blocks
            children = node.childNodes;
            childrenLen = children.length;
            for(i = 0; i &lt; childrenLen; i++){
                nodeInternal = children[i];
                if (nodeInternal.nodeType === Node.TEXT_NODE){
                    elem = nodeInternal.textContent;
                }
                if (nodeInternal.nodeType === Node.ELEMENT_NODE){
                    nodeHtml = nodeInternal.outerHTML;
                    // console.log(nodeInternal.nodeName);
                    methodName = &#x27;create&#x27; + Helper.onlyFirstLetterUpperCase(nodeInternal.nodeName) + &#x27;FromHtml&#x27;;
                    methodExists = (typeof nodeHtml[methodName]) === &#x27;function&#x27;;
                    elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
                }
                output.appendElem(elem);
            }
        }
    }
    return output;
};
String.prototype.createAFromHtml = function(){
    return this.toString().createLinkFromHtml();
};

String.prototype.createLinkFromHtml = function(){
    /**
     * Creates an instance of Link class and fills in its property &quot;elements&quot; with
     * the elements recognized inside the string. It is supposed that the string is of the
     * form &#x60;&lt;tag [tag-attributes] [style=&quot;...&quot;]&gt;....&lt;/tag&gt;&#x60;.
     * @method    createLinkFromHtml
     * @return    {Link|null}
     */

    var str = this.toString(),
        parser = new DOMParser(),
        id = Helper.generateId(str, &#x27;fakeId&#x27;),
        doc = parser.parseFromString(&#x27;&lt;div id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + str + &#x27;&lt;/div&gt;&#x27;, &#x27;text/html&#x27;),
        output = new Link(),
        uniqueNode, uniqueNodeChildren, node, nodeInternal, elem, i , children, childrenLen, attrs, style,
        tagName, nodeHtml, methodName, methodExists, href;
    uniqueNode = doc.getElementById(id);
    uniqueNodeChildren = uniqueNode.childNodes;
    if (uniqueNodeChildren.length === 1){
        node = uniqueNodeChildren[0]; // in fact this is the node corresponding to the target string
        if (node.nodeType === Node.ELEMENT_NODE){
            tagName = node.nodeName;
            output.setTag(tagName.toLowerCase());

            style = node.getAttribute(&#x27;style&#x27;);
            href = node.getAttribute(&#x27;href&#x27;);
            output.setStyles(new LinkStyles(style));
            attrs = Helper.flatten(node.attributes);
            if (attrs.hasOwnProperty(&#x27;style&#x27;)){
                delete attrs.style;
            }
            output.setAttributes(new LinkAttributes(attrs));
            output.setHref(href);
            // split the target string on blocks
            children = node.childNodes;
            childrenLen = children.length;
            for(i = 0; i &lt; childrenLen; i++){
                nodeInternal = children[i];
                if (nodeInternal.nodeType === Node.TEXT_NODE){
                    elem = nodeInternal.textContent;
                }
                if (nodeInternal.nodeType === Node.ELEMENT_NODE){
                    nodeHtml = nodeInternal.outerHTML;
                    methodName = &#x27;create&#x27; + Helper.onlyFirstLetterUpperCase(nodeInternal.nodeName) + &#x27;FromHtml&#x27;;
                    methodExists = (typeof nodeHtml[methodName]) === &#x27;function&#x27;;
                    elem = methodExists ? nodeHtml[methodName]() : nodeHtml.createTagFromHtml();
                }
                output.appendElem(elem);
            }
        }
    }
    return output;
};


String.prototype.inflate = function(){
    /**
     * Creates an instance of Content class and fills in its property &quot;elements&quot; with
     * the elements recognized inside the string.
     * @method    inflate
     * @return    {Content}
     */
    var str, parser, id, doc, output, node, children,
        childrenNum, i, child, childHtml, elem, methodName, methodExists;
    str = this.toString();
    parser = new DOMParser();
    output = new Content();

    id = Helper.generateId(str, &#x27;fakeId&#x27;);
    if (Helper.isSemanticallyValid(str)){
        doc = parser.parseFromString(&#x27;&lt;div id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + str + &#x27;&lt;/div&gt;&#x27;, &#x27;text/html&#x27;);
        node = doc.getElementById(id);
        children = node.childNodes;
        childrenNum = children.length;
        if (childrenNum &gt; 0){
            for (i = 0; i &lt; childrenNum; i++){
                child = children[i];
                switch (child.nodeType){
                    case Node.TEXT_NODE:
                        elem = child.textContent.trim();
                        break;
                    case Node.ELEMENT_NODE:
                        childHtml = child.outerHTML;
                        methodName = &#x27;create&#x27; + Helper.onlyFirstLetterUpperCase(child.nodeName) + &#x27;FromHtml&#x27;;
                        methodExists = (typeof childHtml[methodName] === &#x27;function&#x27;);
                        // if the method exists, apply it to the string representation of
                        // the current node. Otherwise, apply recursively the method &quot;inflate&quot;
                        // to the inner part of the current node.
                        if (methodExists){
                            elem = childHtml[methodName]();
                        } else {
                            elem = childHtml.createTagFromHtml();
                        }
                        break;
                    default:
                        elem = child.nodeValue;
                }
                if (elem){
                    output.appendElem(elem);
                }
            }
        }
    }
    return output;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
