<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\classes\HtmlElements\Tag\Table.js - Newsletter API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..\logo.png" title="Newsletter API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Attributes.html">Attributes</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/Factory.html">Factory</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/ImageStyle.html">ImageStyle</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/LinkAttributes.html">LinkAttributes</a></li>
            
                <li><a href="../classes/LinkStyles.html">LinkStyles</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemStyles.html">ListItemStyles</a></li>
            
                <li><a href="../classes/ListStyles.html">ListStyles</a></li>
            
                <li><a href="../classes/Mapping.html">Mapping</a></li>
            
                <li><a href="../classes/OList.html">OList</a></li>
            
                <li><a href="../classes/PlainText.html">PlainText</a></li>
            
                <li><a href="../classes/Properties.html">Properties</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/StringHelper.html">StringHelper</a></li>
            
                <li><a href="../classes/Styles.html">Styles</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/TableAttributes.html">TableAttributes</a></li>
            
                <li><a href="../classes/TableCellStyles.html">TableCellStyles</a></li>
            
                <li><a href="../classes/TableRowStyles.html">TableRowStyles</a></li>
            
                <li><a href="../classes/TableStyles.html">TableStyles</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/UList.html">UList</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Properties.html">Properties</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\classes\HtmlElements\Tag\Table.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global Attributes, Cell, Helper, TableStyles, Styles, TableAttributes, Row, Tag, Content */

/**
* Represents table.
*
* Table might be a plain one or a framed one. Table is called framed if each of its rows contains only one cell,
* and each of these cells contains another table. These three elements - row, cell and table - are called phantom ones.
* Only {{#crossLink &quot;Tag/styles:property&quot;}}styles{{/crossLink}} and
* {{#crossLink &quot;Tag/attributes:property&quot;}}attributes{{/crossLink}} of the phantom elements are of interest
*
*
* Below it is depicted a framed table. Dotted lines correspond to the phantom elements, solid - to &quot;normal&quot; ones.
* &lt;span style=&quot;color: black&quot;&gt;Black color corresponds to table&lt;/span&gt;,
* &lt;span style=&quot;color: orange&quot;&gt;orange - to table row&lt;/span&gt;,
* &lt;span style=&quot;color: green&quot;&gt;green - to table cell&lt;/span&gt;.
* &lt;style&gt;
* .phantom, .normal{
*	border-width: 2px;
*	padding: 4px;
* 	margin: 4px;
*	border-collapse: separate;
* }
*
* .phantom {
* 	border-style: dashed;
* }
* .normal {
*   border-style: solid;
* }
* table.phantom, table.normal {
*	border-color: #2818B1;
*	padding: 10px;
* }
* td.phantom, td.normal{
* 	border-color: #00A779;
* }
* tr.phantom, tr.normal {
* 	outline-width: 2px;
* 	outline-color: #FF9C00;
* }
* tr.phantom{
* 	outline-style: dashed;
* }
* tr.normal {
* 	outline-style: solid;
* }

* &lt;/style&gt;
*
* &lt;table class=&quot;normal&quot;&gt;
* 	&lt;tr class=&quot;phantom&quot;&gt;
*  		&lt;td class=&quot;phantom&quot;&gt;
*  			&lt;table class=&quot;phantom&quot;&gt;
*  				&lt;tr class=&quot;normal&quot;&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						first cell of the first line
*  					&lt;/td&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						second cell of the first line
*  					&lt;/td&gt;
*  				&lt;/tr&gt;
*  			&lt;/table&gt;
*  		&lt;/td&gt;
*   &lt;/tr&gt;
* 	&lt;tr class=&quot;phantom&quot;&gt;
*  		&lt;td class=&quot;phantom&quot;&gt;
*  			&lt;table class=&quot;phantom&quot;&gt;
*  				&lt;tr class=&quot;normal&quot;&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						first cell of the second line
*  					&lt;/td&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						second cell of the second line
*  					&lt;/td&gt;
*  				&lt;/tr&gt;
*  			&lt;/table&gt;
*  		&lt;/td&gt;
*   &lt;/tr&gt;
* &lt;/table&gt;
* @module        HtmlElements
* @class         Table
* @constructor
* @extends       Tag
*/
function Table() {
	&quot;use strict&quot;;
	if (!(this instanceof Table)) {
		return new Table();
	}
	// inherit tag properties
	Tag.call(this);


	/**
	 * Re-set private properties defined in parent class {{#crossLink &quot;Tag&quot;}}Tag{{/crossLink}}:
	 * &lt;ol&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/tag:property&quot;}}tag{{/crossLink}} to be &quot;table&quot;
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/className:property&quot;}}className{{/crossLink}} to be &quot;Table&quot;
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/styles:property&quot;}}styles{{/crossLink}} to be
	 * {{#crossLink &quot;TableStyles&quot;}}TableStyles{{/crossLink}}
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/attributes:property&quot;}}styles{{/crossLink}} to be
	 * {{#crossLink &quot;TableAttributes&quot;}}TableAttributes{{/crossLink}}
	 * &lt;/li&gt;&lt;/ol&gt;
	 * @method         constructor
	 */
	this.setTag(&#x27;table&#x27;);
	this.setName(&#x27;Table&#x27;);
	this.setStyles(new TableStyles());
	this.setAttributes(new TableAttributes());

	/**
	 * Phantom cell.
	 * @property       {Cell}    phantomCell
	 * @type           {Cell}
	 * @private
	 * @default        undefined
	 */
	var phantomCell;

	/**
	 * Phantom row.
	 * @property       {Row}    phantomRow
	 * @type           {Row}
	 * @private
	 * @default        undefined
	 */
	var phantomRow;


	/**
	 * Phantom table {{#crossLink &quot;Styles&quot;}}styles{{/crossLink}}.
	 * @property       {Table}    phantomTable
	 * @type           {Table}
	 * @private
	 * @default        undefined
	 */
	var phantomTable;

	/**
	 * Initializes {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}} if not initialized.
	 * If they are initialized, no re-initialization happens.
	 * @method          setPhantoms
	 * @return          void
	 */
	this.initPhantoms = function(){
		if (!(phantomRow instanceof Row)){
			phantomRow = new Row();
		}
		if (!(phantomCell instanceof Cell)){
			phantomCell = new Cell();
		}
		if (!(phantomTable instanceof Table)){
			phantomTable = new Table();
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomCellStyles{{/crossLink}} getter.
	 * @method         getPhantomCellStyles
	 * @return         {Styles}
	 */
	this.getPhantomCellStyles = function(){
		if (phantomCell instanceof Cell){
			return phantomCell.getStyles();
		}

	};

	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomCellStyles{{/crossLink}} setter.
	 * @method         setPhantomCellStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomCellStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Styles){
				phantomCell.setStyles(stl);
			} else {
				phantomCell.setStyles(new Styles(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomRowStyles{{/crossLink}} getter.
	 * @method         getPhantomRowStyles
	 * @return         {Styles}
	 */
	this.getPhantomRowStyles = function(){
		if (phantomRow instanceof Row){
			return phantomRow.getStyles();
		}
	};

	/**
	 * {{#crossLink &quot;Table/phantomRowStyles:property&quot;}}setPhantomRowStyles{{/crossLink}} setter.
	 * @method         setPhantomRowStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomRowStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Styles){
				phantomRow.setStyles(stl);
			} else {
				phantomRow.setStyles(new Styles(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomTableStyles:property&quot;}}phantomTableStyles{{/crossLink}} getter.
	 * @method         getPhantomTableStyles
	 * @return         {Styles}
	 */
	this.getPhantomTableStyles = function(){
		if (phantomTable instanceof Table){
			return phantomTable.getStyles();
		}
	};

	/**
	 * {{#crossLink &quot;Table/phantomTableStyles:property&quot;}}phantomTableStyles{{/crossLink}} setter.
	 * @method         setPhantomTableStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomTableStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Styles){
				phantomTable.setStyles(stl);
			} else {
				phantomTable.setStyles(new Styles(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;FramedTable/phantomCellAttributes:property&quot;}}phantomCellAttributes{{/crossLink}} getter.
	 * @method         getPhantomCellAttributes
	 * @return         {Attributes}
	 */
	this.getPhantomCellAttributes = function(){
		if (phantomCell instanceof Cell){
			return phantomCell.getAttributes();
		}

	};

	/**
	 * {{#crossLink &quot;FramedTable/phantomCellAttributes:property&quot;}}phantomCellAttributes{{/crossLink}} setter.
	 * @method         setPhantomCellAttributes
	 * @param          {Properties}             attr
	 * @return         {void}
	 */
	this.setPhantomCellAttributes = function(attr){
		if (attr !== undefined){
			this.initPhantoms();
			if (attr instanceof Attributes){
				phantomCell.setAttributes(attr);
			} else {
				phantomCell.setAttributes(new Attributes(attr));
			}
		}
	};

	/**
	 * Returns &#x60;true&#x60; if the content of the instance contains the only element
	 * which is a &quot;tbody&quot; tag instance.
	 * @method           hasTBody
	 * @return           {Boolean}
	 */
	// this.hasTBody = function(){
	// 	console.log(this.getElements());
	// 	return this.getElements().length === 1 &amp;&amp; this.getElements()[0].getTag() === &#x27;tbody&#x27;;
	// }

	/**
	 * {{#crossLink &quot;FramedTable/phantomRowAttributes:property&quot;}}phantomRowAttributes{{/crossLink}} getter.
	 * @method         getPhantomRowAttributes
	 * @return         {Attributes}
	 */
	this.getPhantomRowAttributes = function(){
		if (phantomRow instanceof Row){
			return phantomRow.getAttributes();
		}

	};

	/**
	 * {{#crossLink &quot;FramedTable/phantomRowAttributes:property&quot;}}phantomRowAttributes{{/crossLink}} setter.
	 * @method         setPhantomRowAttributes
	 * @param          {Properties}         attr
	 * @return         {void}
	 */
	this.setPhantomRowAttributes = function(attr){
		if (attr !== undefined){
			this.initPhantoms();
			if (attr instanceof Attributes){
				phantomRow.setAttributes(attr);
			} else {
				phantomRow.setAttributes(new Attributes(attr));
			}
		}
	};

	/**
	 * {{#crossLink &quot;FramedTable/phantomTableAttributes:property&quot;}}phantomTableAttributes{{/crossLink}} getter.
	 * @method         getPhantomTableAttributes
	 * @return         {Attributes}
	 */
	this.getPhantomTableAttributes = function(){
		if (phantomTable instanceof Table){
			return phantomTable.getAttributes();
		}

	};

	/**
	 * {{#crossLink &quot;FramedTable/phantomTableAttributes:property&quot;}}phantomTableAttributes{{/crossLink}} setter.
	 * @method         setPhantomTableAttributes
	 * @param          {Properties}         attr
	 * @return         {void}
	 */
	this.setPhantomTableAttributes = function(attr){
		if (attr !== undefined){
			this.initPhantoms();
			if (attr instanceof Attributes){
				phantomTable.setAttributes(attr);
			} else {
				phantomTable.setAttributes(new Attributes(attr));
			}
		}
	};

	/**
	 * Returns {{#crossLink &quot;Tag/openingTag:method&quot;}}opening{{/crossLink}} or
	 * {{#crossLink &quot;Tag/closingTag:method&quot;}}closing{{/crossLink}} tag for one of the
	 * phantom elements: {{#crossLink &quot;Table/phantomCell:property&quot;}}cell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}row{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}table{{/crossLink}}.
	 * @method         getPhantomTag
	 * @param          {String}             phantomElem       &quot;cell&quot;, &quot;row&quot;, &quot;table&quot; (case insensitive)
	 * @param          {String|Null}        type              &quot;open&quot; or &quot;close&quot; (case insensitive).
	 *                                                        If missing, supposed to be equal to &quot;open&quot;.
	 * @return         {String}
	 */
	this.getPhantomTag = function(phantomElem, type){
		if (typeof phantomElem === &#x27;string&#x27;){
			var phElemName = phantomElem.toLowerCase(),
				tagType = (typeof type === &#x27;string&#x27; &amp;&amp; type.toLowerCase() === &#x27;close&#x27;) ? &#x27;closingTag&#x27; : &#x27;openingTag&#x27;;
			if (phElemName === &#x27;cell&#x27; &amp;&amp; phantomCell !== undefined &amp;&amp; typeof phantomCell[tagType] === &#x27;function&#x27;) {
				return phantomCell[tagType]();
			}
			if (phElemName === &#x27;row&#x27; &amp;&amp; phantomRow !== undefined &amp;&amp; typeof phantomRow[tagType] === &#x27;function&#x27;) {
				return phantomRow[tagType]();
			}
			if (phElemName === &#x27;table&#x27; &amp;&amp; phantomTable !== undefined &amp;&amp; typeof phantomTable[tagType] === &#x27;function&#x27;) {
				return phantomTable[tagType]();
			}
		}
	};


	/**
	 * The number of the rows in the table. It scans {{#crossLink &quot;Table/content:property&quot;}}content{{/crossLink}}
	 * of the instance until the first occurrence of &#x60;tbody&#x60; tag. Once found, its length is returned. If not found,
	 * zero is returned.
	 * @method  rowNum
	 * @return {Number}
	 */
	this.rowNum = function(){
		var cntn = this.getBody();
		return cntn ? cntn.length : 0;
	};

	/**
	 * Sets &#x60;tbody&#x60; part of the table. The argument must be either a {{#crossLink &quot;Row&quot;}}Row{{/crossLink}}
	 * instance or an array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances.
	 * Otherwise, an error is thrown.
	 *
	 * Even though not more than one instance of &#x60;tbody&#x60; must be present among
	 * {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}}
	 * {{#crossLink &quot;Content/elements:property&quot;}}elements{{/crossLink}}, all &#x60;tbody&#x60; tags are first dropped
	 * from {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}} and then the requested one is inserted.
	 * @method         setBody
	 * @param          {array|Row}  body    array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances or
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instance
	 * @return         {void}
	 * @since          0.0.5
	 */
	this.setBody = function(body){
		var bodyArr = Array.isArray(body) ? body : [body],
			valid;
		valid = bodyArr.every(function(elem){
			return (elem instanceof Row);
		});

		if (!valid){
			throw new Error(&#x27;Instance of Row class is required to be set as tbody!&#x27;);
		}
		var cntn = this.getContent(),
			oldTBodyPos = cntn.findTagPos(&#x27;tbody&#x27;),
			newTbody = new Tag(&#x27;tbody&#x27;);
		newTbody.setElements(bodyArr);
		if (oldTBodyPos.length &gt; 0){
			oldTBodyPos.sort(function(a, b){return b - a;});  // sort elements in descreasing order
			oldTBodyPos.forEach(function(pos){
				cntn.dropElemAt(pos);
			});
		}
		cntn.appendElem(newTbody);
		this.setContent(cntn);
	};


	/**
	 * Alias for {{#crossLink &quot;Table/setBody:method&quot;}}setBody{{/crossLink}} method.
	 *
	 * Overrides parent method {{#crossLink &quot;Tag/setElements:method&quot;}}setElements{{/crossLink}}.
	 * @method         setElements
	 * @param          {array|Row}  elems    array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances or
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instance
	 */
	this.setElements = function(elems){
		this.setBody(elems);
	};

	/**
	 * Returns array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances in &#x60;tbody&#x60; part of the table.
	 * @method         getBody
	 * @return         {Array}              one dimensional array of
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances
	 *                                      or empty array
	 * @since          0.0.5
	 */
	this.getBody = function(){
		var cntn = this.getContent(),
			tbody = cntn.getFirstEntryOfTag(&#x27;tbody&#x27;);
		return tbody ? tbody.getElements() : [];
	};

	/**
	 * Returns footer of the table.
	 * @method         getFooter
	 * @return         {Tag|Null}
	 */
	this.getFooter = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;tfoot&#x27;);
		}
	};

	/**
	 * Returns header of the table.
	 * @method         getHeader
	 * @return         {Tag|Null}
	 */
	this.getHeader = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;thead&#x27;);
		}
	};

	/**
	 * Returns header of the table.
	 * @method         getCaption
	 * @return         {Tag|Null}
	 */
	this.getCaption = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;caption&#x27;);
		}
	};

	/**
	 * Appends a row to the content property. If the argument is not a Row instance, an error is thrown.
	 * @method   appendRow
	 * @param    {Object} row     a row to append. If not a Row instance, an error is thrown.
	 * @return   {void}
	 */
	this.appendRow = function(row){
		if (!(row instanceof Row)){
			throw new Error(&#x27;The argument is not a Row instance!&#x27;);
		}
		var cntn = this.getContent(),
			tbody = cntn.getFirstEntryOfTag(&#x27;tbody&#x27;);
		if (tbody){
			tbody.appendElem(row);
			// this.
		} else {
			tbody = new Tag(&#x27;tbody&#x27;);
			tbody.setElements([row]);
			cntn.appendElem(tbody);
		}
		// cntn.filterOut(function(el){return elem.getTag() === &#x27;tbody&#x27;;});
		this.setContent(cntn);
	};

	/**
	 * Gives a two-dimensional array [[w_11, w_12, ..., w_1n], ..., [w_m1, w_m2, ..., w_m3]]
	 * where w_ij is width of the cell located in the row i and column j.
	 * @method  getMatrix
	 * @return {Array}
	 */
	this.getMatrix = function(){
		var output = [],
			rowsNum = this.rowNum(), i,
			body = this.getBody();
		for (i = 0; i &lt; rowsNum; i++){
			output.push(body[i].getCellWidths());
		}
		//console.log(&#x27;Table::getMatrix() returning &#x27;, output);
		return output;
	};

	/**
	 * Returns array of widths of the cells in the table rows if all rows
	 * have the same cell widths. Otherwise null is returned.
	 * @method  getProfile
	 * @return {Array|Null}
	 */
	this.getProfile = function (){
		var output = this.isSameWidths() ? this.getMatrix()[0] : null;
		//console.log(&#x27;Table::getProfile() returning &#x27;, output);
		return output;
	};

	/**
	 * Imposes the widths of all cell in all rows of the table body. If the argument is not array, an error is thrown.
	 * If the array length is different from the number of columns, an error is thrown. Otherwise, it is called
	 * method {{#crossLink &quot;Row/setCellWidths:method&quot;}}setCellWidths{{/crossLink}} on each row of table body.
	 * @method         setProfile
	 * @param          {Array}         profile      an array of cell widths that will be applied to each row.
	 * @return         {void}
	 */
	this.setProfile = function(profile){
		var len = this.rowNum(),
			cols = this.colNum(),
			i;
		console.log(&#x27;Table has &#x27; , len, &#x27; rows&#x27;);
		if (!Array.isArray(profile)){
			throw new Error(&#x27;Wrong argument type: array expected.&#x27;);
		}
		if (profile.length !== cols){
			console.log(&quot;profile: &quot;, profile, &quot;cols = &quot;, cols);
			throw new Error(&#x27;Wrong input array length!&#x27;);
		}
		var tbody = this.getBody();
		for (i = 0; i &lt; len; i++){
			console.log(&#x27;elem &#x27; + i + &#x27;before: &#x27; + tbody[i].toHtml());
			tbody[i].setCellWidths(profile);
			console.log(&#x27;elem &#x27; + i + &#x27; after: &#x27; + tbody[i].toHtml());
		}
		this.setBody(tbody);
	};

	/**
	 * Inserts a cell &quot;cell&quot; into a given position &quot;pos&quot; of each row of the table.
	 * If the table has 5 columns, then after insertion it will have 5+1=6 columns.
	 * Position &quot;pos&quot; will correspond to the index of the inserted cell in the row after insertion.
	 * &quot;pos&quot; must be a valid cell number into the table after insertion. So, for the example above,
	 * the valid values for &quot;pos&quot; are 0, 1, 2, 3, 4 and 5.
	 * @method insertColAt
	 * @param  {Cell} 	cell
	 * @param  {Number} pos
	 * @return {void}
	 */
	this.insertColAt = function(pos, cell){
		cell = cell || (new Cell());
		var colNum = this.colNum(),
			rowNum = this.rowNum(),
			tbody = this.getBody(),
			i;

		if (colNum &lt;= 0 || pos &lt; 0 || pos &gt; colNum){
			throw new Error(&#x27;Wrong index for the cell to insert!&#x27;);
		}
		if (pos &lt; colNum){
			for (i = 0; i &lt; rowNum; i++){
				tbody[i].insertCellAt(pos, cell);
			}
		} else {
			for (i = 0; i &lt; rowNum; i++){
				tbody[i].appendCell(cell);
			}
		}
		this.setBody(tbody);

		return null;
	};

	/**
	 * insertColumnAt was renamed into Table::insertColAt(). So, this method is added for back-compatibility .
	 * @method        insertColumnAt
	 * @param         {pos}      pos
	 * @param         {cell}     cell
	 * @return        {void}
	 * @deprecated    Use Table::insertColAt() directly.
	 */
	this.insertColumnAt = function(pos, cell){
		console.log(&#x27;Table::insertColumnAt() was called. Try to eliminate this call.&#x27;);
		this.insertColAt(pos, cell);
	};

	/**
	 * Knocks out given column from the table. The operation is delegated to the &#x60;Row::knockOutCell()&#x60;
	 * @method knockOutCol
	 * @param  {integer} 	colNum        the number of the column to be knocked out. Numeration starts with 0.
	 * @return {void}
	 */
	this.knockOutCol = function(colNum){
		var rowsNum = this.rowNum(),
			tbody = this.getBody(),
			i;
		for (i = 0; i &lt; rowsNum; i++){
			tbody[i].knockOutCell(colNum);
		}
		this.setBody(tbody);
	};

	/**
	 * dropColumn was renamed into Table::knockOutCol(). So, this method is added for back-compatibility .
	 * @method  dropColumn
	 * @param  {pos}      pos
	 * @param  {cell}     cell
	 * @return {void}
	 * @deprecated  Use Table::knockOutCol() directly.
	 */
	this.dropColumn = function(pos, cell){
		console.log(&#x27;Table::dropColumn() was called. Try to eliminate this call by using Table::knockOutCol() directly.&#x27;);
		this.knockOutCol(pos, cell);
	};


	/**
	 * Drops specified column from the table. The operation is delegated to the &#x60;Row::dropCellAt()&#x60;
	 * @method dropColAt
	 * @param  {integer} 	colNum           the number of the column to delete. Numeration starts with 0.
	 * @return {void}
	 */
	this.dropColAt = function(colNum){
		var rowsNum = this.rowNum(),
			tbody = this.getBody(),
			i;
		for (i = 0; i &lt; rowsNum; i++){
			tbody[i].dropCellAt(colNum);
		}
		this.setBody(tbody);
	};

	/**
	 * Gives the number of columns in the table or null if not all rows have the same number of cells.
	 * The operation is delegated to the &#x60;Row::cellNum()&#x60;.
	 * @method  colNum
	 * @return {Number|null}
	 */
	this.colNum = function(){
		var rowNum = this.rowNum(),
			firstRowCellNum, i, tbody;
		// if table has no rows, return 0 as number of column
		if (rowNum === 0){
			return 0;
		}
		tbody = this.getBody();
		// console.log(this.getElem(0).toHtml());
		firstRowCellNum = tbody[0].cellNum();
		// if the table has a unique row
		if (rowNum === 1){
			return firstRowCellNum;
		}

		for (i = 1; i &lt; rowNum; i++){
			if (tbody[i].cellNum() !== firstRowCellNum){
				return null;
			}
		}
		return firstRowCellNum;
	};

	/**
	 * Whether all rows in the table have the same cell widths.
	 * @method isSameWidth
	 * @return {Boolean} true, if all rows have the same cells&#x27; widths, false otherwise.
	 */
	this.isSameWidths = function(){
		var matrix = this.getMatrix(),
			rowsNum = matrix.length,
			output = true,
			firstRow, firstRowLen, i, j;
			//console.log(&#x27;table::isSameWidth: matrix=&#x27;, matrix);
		// only if the number of rows is bigger than 1
		if (rowsNum &gt; 1){
			// compare the first row with the rest
			firstRow = matrix[0];
			firstRowLen = firstRow.length;
			for (i = 1; i &lt; rowsNum; i++){
				if (matrix[i].length !== firstRowLen){
					output = false;
					break;
				}
				// compare element by element
				for (j = 0; j &lt; firstRowLen; j++){
					if(matrix[i][j] !== firstRow[j]){
						output = false;
						break;
					}
				}
				// exit as well from outer loop if necessary
				if (!output){
					break;
				}
			}
		}
		return output;
	};

	/**
	 * Set the border of the table. It updates the properties &#x27;attr&#x27; and &#x27;style&#x27; of the instance:
	 * 1. in &#x27;style&#x27; property, sets up the following properties: &#x27;border-width&#x27;, &#x27;border-color&#x27; and &#x27;border-style&#x27;
	 * 2. in &#x27;attr&#x27; property, sets up &#x27;border&#x27; property.
	 * Note that if after setting the border there is an assigment of &#x27;style&#x27; or &#x27;attr&#x27; property, then some info about the border might be overwritten.
	 * @method  setBorder
	 * @param   {Object}     borderInfo        Object containing &#x27;width&#x27;, &#x27;color&#x27; and &#x27;style&#x27; for the border to set.
	 * @default border-width is set to 1, border-color is set to #000000, border-style is set to solid.
	 * @return {void}
	 */
	this.setBorder = function(borderInfo){
		var bw, bc, bs;
		if (borderInfo === undefined){
			borderInfo = {&#x27;width&#x27;: 1, &#x27;color&#x27;: &#x27;#000000&#x27;, &#x27;style&#x27;: &#x27;solid&#x27;};
		}
		bw = borderInfo.width || 1;
		bc = borderInfo.color || &#x27;#000000&#x27;;
		bs = borderInfo.style || &#x27;solid&#x27;;

		this.setStyleProperty(&#x27;border-width&#x27;, bw);
		this.setStyleProperty(&#x27;border-color&#x27;, bc);
		this.setStyleProperty(&#x27;border-style&#x27;, bs);
		this.setAttrProperty(&#x27;border&#x27;, bw);
	};

	/**
	 * Removes the border of the table. It updates the properties &#x27;attr&#x27; and &#x27;style&#x27; of the instance:
	 * 1. in &#x27;style&#x27; property, deletes the properties: &#x27;border-width&#x27;, &#x27;border-color&#x27; and sets up &#x27;border-style&#x27; to &#x27;none&#x27;
	 * 2. in &#x27;attr&#x27; property, deletes &#x27;border&#x27; property.
	 * @method  removeBorder
	 * @return {void}
	 */
	this.removeBorder = function(){
		if (this.getStyles().hasProperty(&#x27;border-width&#x27;)) {
			this.dropStyleProperty(&#x27;border-width&#x27;);
		}
		if (this.getStyles().hasProperty(&#x27;border-color&#x27;)) {
			this.dropStyleProperty(&#x27;border-color&#x27;);
		}
		this.setStyleProperty(&#x27;border-style&#x27;, &#x27;none&#x27;);

		if (this.getAttributes().hasProperty(&#x27;border&#x27;)) {
			this.dropAttrProperty(&#x27;border&#x27;);
		}
	};

	/**
	 * Returns true if the table is fragmented, and false otherwise. It takes table rows and calls method
	 * {{#crossLink &quot;Row/onlyTableInside:method&quot;}}onlyTableInside{{/crossLink}} on each of them until
	 * first &quot;false&quot; is encountered.
	 *
	 * A table is a __framed table__ if all table rows have only one cell and this cell contains
	 * only one element that is a Table instance.
	 * @method         isFragmented
	 * @return         {Boolean}            true if the table is framed, and false otherwise
	 */
	this.isFragmented = function(){
		// console.log(&#x27;number of rows = &#x27;, this.rowNum(), &#x27;, table: &#x27;, this.toHtml());
		if (this.rowNum() === 0){
			return false;
		}
		return this.getBody().every(function(row){
			// console.log(&#x27;row? &#x27;, row.toHtml());
			var res = row.onlyTableInside();
			// console.log(res ? &#x27;returning true&#x27; : &#x27;returning false&#x27;);
			return res;
		});
	};

	/**
	 * Returns &#x60;true&#x60; if at least one of the following variables  {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}} is set. &#x60;False&#x60; otherwise.
	 * @method         isFramed
	 * @return         {Boolean}
	 */
	this.isFramed = function(){
		return (phantomRow !== undefined) || (phantomCell !== undefined) || (phantomTable !== undefined);
	};

	/**
	 * Unsets phantom properties. After resetting those properties, the table becomes a table without frame.
	 * @method unsetPhantom
	 * @return {void}
	 */
	this.unsetPhantom = function(){
		phantomRow = undefined;
		phantomCell = undefined;
		phantomTable = undefined;
	};

	/**
	 * Appends the style to the column. If the column exists, the method call &#x60;Row::appendStyleToCell()&#x60;
	 * on each of the table rows.
	 * @method appendStyleToCol
	 * @param  {Number}        colNum    column number to which the style is to be appended.
	 * @param  {Style|Object}  style     Style or Object to be appended
	 * @return {void}
	 */
	this.appendStyleToCol = function(colNum, style){
		var colNumInt = parseInt(colNum, 10),
			colLen = this.colNum(),
			rowLen = this.rowNum(),
			tbody = this.getBody(),
			i;
		if (colNumInt === colNum &amp;&amp; colNum &gt;= 0 &amp;&amp; colNum &lt; colLen) {
			for (i = 0; i &lt; rowLen; i++){
				tbody[i].appendStyleToCellAt(colNum, style);
			}
			this.setBody(tbody);
		} else {
			throw new Error(&#x27;The column is not present!&#x27;);
		}
	};

	/**
	 * Generates html representation of the table body. If table is framed, then each row is &quot;sandwiched&quot; with
	 * phantom elements.
	 * @method         bodyToHtml
	 * @param          {Boolean}            withFrame         whether the table is framed or not.
	 * @return         {String}
	 * @since          0.0.5
	 */
	this.bodyToHtml = function(){
		var prologue = &#x27;&#x27;,
			epilogue  = &#x27;&#x27;,
			bodyHtml = &#x27;&#x27;;
		if (this.isFramed()){
			epilogue = this.getPhantomTag(&#x27;row&#x27;, &#x27;open&#x27;) + this.getPhantomTag(&#x27;cell&#x27;, &#x27;open&#x27;) + this.getPhantomTag(&#x27;table&#x27;, &#x27;open&#x27;);
			prologue = this.getPhantomTag(&#x27;table&#x27;, &#x27;close&#x27;) + this.getPhantomTag(&#x27;cell&#x27;, &#x27;close&#x27;) + this.getPhantomTag(&#x27;row&#x27;, &#x27;close&#x27;);
		}
		this.getBody().forEach(function(el){
			if (typeof el.toHtml === &#x27;function&#x27;){
				bodyHtml += epilogue + el.toHtml() + prologue;
			}
		});
		return bodyHtml;
	};

	/**
	 * Generates html code corresponding to this instance. Eventually, wraps each element of
	 * {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}} with strings corresponding to phantom
	 * elements. Generation of html string of each {{#crossLink &quot;Tag/content:property&quot;}}content element{{/crossLink}}
	 * is delegated to its &#x60;toHtml&#x60; method (if the elements has &#x60;toHtml&#x60; method, this element gets ignored).
	 * @method         toHtml
	 * @return         {String}
	 */
	this.toHtml = function () {
		var tableHtml  = this.openingTag();
		var that = this;

		this.getElements().forEach(function(el){
			if (typeof el.toHtml === &#x27;function&#x27;){
				if (el.getTag() === &#x27;tbody&#x27;){
					tableHtml += el.openingTag() + that.bodyToHtml() + el.closingTag();
				} else {
					tableHtml += el.toHtml();
				}

			}
		});
		tableHtml += this.closingTag();
		return tableHtml;
	};


	/**
	 * If the table is fragmented and all rows have the same requested property, then
	 * this property of the first row is returned. In any other case, null is returned.
	 * NB: to compare requested property for all rows, this property must be an object
	 * with boolean-valued method isTheSameAs().
	 * @method   getPhantomRowProp
	 * @param    {String}         prop      a tag of the property to return. All rows should have this property.
	 * @return   {Object|null}			    the value of the property specified by the argument, if it is the same
	 *                                      for all rows, null otherwise.
	 */
	this.getPhantomRowProp = function(prop){
		if (!this.isFragmented()){
			return null;
		}
		var firstRow = this.getFirst(),
			rowNum = this.rowNum(),
			rowProp, i, firstRowProp;
		switch (prop){
			case &#x27;attr&#x27;:
				firstRowProp = firstRow.getAttributes();
				break;
			case &#x27;style&#x27;:
				firstRowProp = firstRow.getStyles();
				break;
			default:
				return null;
		}
		if (rowNum === 1){
			return firstRowProp;
		}
		if (typeof firstRowProp.isTheSameAs !== &#x27;function&#x27;){
			return null;
		}
		for (i = 1; i &lt; rowNum; i++){
			rowProp = (prop === &#x27;style&#x27;) ? (this.getElem(i).getStyles()) : (prop === &#x27;attr&#x27; ? this.getElem(i).getAttributes() : null) ;
			if (!firstRowProp.isTheSameAs(rowProp)){
				return null;
			}
		}
		return firstRowProp;

	};

	/**
	 * Gets copy of n-th row stored in table body. If that row does not exist, nothing is returned.
	 * @method        getRow
	 * @param         {Number}    n
	 * @return        {Row|Null}
	 * @since         0.0.5
	 */
	this.getRow = function(n){
		if (n !== undefined){
			var len = this.rowNum();
			if (len &gt; 0 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; len){
				return this.getBody()[n];
			}
		}
	};

	/**
	 * Returns copy of the first row stored in table body. If that row does not exist, nothing is returned.
	 * @method         getFirstRow
	 * @return         {Row}
	 * @since          0.0.5
	 */
	this.getFirstRow = function(){
		if (this.rowNum() &gt; 0){
			return this.getBody()[0];
		}
	};

	/**
	 * Returns copy of last row stored in table body. If that row does not exist, nothing is returned.
	 * @method        getLastRow
	 * @return        {Row}
	 * @since         0.0.5
	 */
	this.getLastRow = function(){
		var len = this.rowNum();
		if (len &gt; 0){
			return this.getBody()[len - 1];
		}
	};

	/**
	 * If the table is fragmented, gives the requested property of the phantom cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method        getPhantomCellProp
	 * @param         {String}              propName            requested property (supposed to be &quot;style&quot; or &quot;attr&quot;)
	 * @return        {Object|null}
	 */
	this.getPhantomCellProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getPhantomCellProp(propName);
		console.log(&#x27;Table::getPhantomCellProp : firstRowProp(&#x27;, propName, &#x27;) = &#x27;, firstRowProp);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getPhantomCellProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;
	};

	/**
	 * If the table is fragmented, gives the requested property of the phantom cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method  getPhantomTableProp
	 * @param   {String}     propName            requested property (supposed to be &quot;style&quot; or &quot;attr&quot;)
	 * @return  {Object|null}
	 */
	this.getPhantomTableProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getPhantomTableProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getPhantomTableProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;

	};


	/**
	 * If the table is fragmented, then sets up the phantom properties and rearrange content property.
	 * If not, the table remains as it is.
	 *
	 * NB: refactor it!!!!
	 *
	 * NB: note that disentanglement only of table body occurs. If table header contains fragmented table,
	 * it remains untouched.
	 * @method   desintangle
	 * @return   {void}
	 */
	this.disentangle = function(){
		if (!this.isFragmented()){
			return null;
		}
		var rows = [],
			rowNum = this.rowNum(),
			i,
			firstRow = this.getFirstRow(),
			cellInside = firstRow.getFirst(),
			tableInside = cellInside.getFirst();

		this.setPhantomRowStyles(firstRow.getStyles());
		this.setPhantomRowAttributes(firstRow.getAttributes());

		this.setPhantomCellStyles(cellInside.getStyles());
		this.setPhantomCellAttributes(cellInside.getAttributes());

		this.setPhantomTableStyles(tableInside.getStyles());
		this.setPhantomTableAttributes(tableInside.getAttributes());

		for (i = 0; i &lt; rowNum; i++){
			rows.push(this.getRow(i).getFirst().getFirst().getFirstRow());
		}
		this.setBody(rows);
	};


}
Table.prototype = Object.create(Tag.prototype);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
