<!DOCTYPE html>
<html>
  <head>
    <title>Zombie.js</title>
    <link href="style/zombie.css" rel="stylesheet">
    <script src="style/zombie.js"></script>
    <meta name="viewport" content="initial-scale = 1.0">
  </head>
  <body>
    <div id="navigation-bar" class="contracted">
      <ul></ul>
      <a class="expand"><span></span></a>
    </div>
    <div class="content">
      <h1 id="zombie.js">Zombie.js</h1>

<h2 id="browser">Browser</h2>

<h4>browser.assert</h4>

<p>Methods for making assertions against the browser, such as
<code>browser.assert.element(".foo")</code>.</p>

<p>See <a href="#assertions">Assertions</a> for detailed discussion.</p>

<h4>browser.console</h4>

<p>Provides access to the browser console (same as <code>window.console</code>).</p>

<h4>browser.referer</h4>

<p>You can use this to set the HTTP Referer header.</p>

<h4>browser.resources</h4>

<p>Access to history of retrieved resources.  Also provides methods for retrieving
resources and managing the resource pipeline.  When things are not going your
way, try calling <code>browser.resources.dump()</code>.</p>

<p>See <a href="#resources">Resources</a> for detailed discussion.</p>

<h4>browser.tabs</h4>

<p>Array of all open tabs (windows).  Allows you to operate on more than one open
window at a time.</p>

<p>See <a href="#tabs">Tabs</a> for detailed discussion.</p>

<h4>browser.eventLoop</h4>

<h4>browser.errors</h4>

<h3 id="extending_the browser">Extending The Browser</h3>

<pre><code>Browser.extend(function(browser) {
  browser.on("console", function(level, message) {
    logger.log(message);
  });
  browser.on("log", function(level, message) {
    logger.log(message);
  });
});
</code></pre>

<h2 id="tabs">Tabs</h2>

<p>Just like your favorite Web browser, Zombie manages multiple open windows as
tabs.  New browsers start without any open tabs.  As you visit the first page,
Zombie will open a tab for it.</p>

<p>All operations against the <code>browser</code> object operate on the currently active tab
(window) and most of the time you only need to interact with that one tab.  You
can access it directly via <code>browser.window</code>.</p>

<p>Web pages can open additional tabs using the <code>window.open</code> method, or whenever a
link or form specifies a target (e.g. <code>target=_blank</code> or <code>target=window-name</code>).
You can also open additional tabs by calling <code>browser.open</code>.  To close the
currently active tab, close the window itself.</p>

<p>You can access all open tabs from <code>browser.tabs</code>.  This property is an
associative array, you can access each tab by its index number, and iterate over
all open tabs using functions like <code>forEach</code> and <code>map</code>.</p>

<p>If a window was opened with a name, you can also access it by its name.  Since
names may conflict with reserved properties/methods, you may need to use
<code>browser.tabs.find</code>.</p>

<p>The value of a tab is the currently active window.  That window changes when you
navigate forwards and backwards in history.  For example, if you visited the URL
"/foo" and then the URL "/bar", the first tab (<code>browser.tabs[0]</code>) would be a
window with the document from "/bar".  If you then navigate back in history, the
first tab would be the window with the document "/foo".</p>

<p>The following operations are used for managing tabs:</p>

<h4>browser.close(window)</h4>

<p>Closes the tab with the given window.</p>

<h4>browser.close()</h4>

<p>Closes the currently open tab.</p>

<h4>browser.tabs</h4>

<p>Returns an array of all open tabs.</p>

<h4>browser.tabs[number]</h4>

<p>Returns the tab with that index number.</p>

<h4>browser.tabs[string]</h4>

<h4>browser.tabs.find(string)</h4>

<p>Returns the tab with that name.</p>

<h4>browser.tabs.closeAll()</h4>

<p>Closes all tabs.</p>

<h4>browser.tabs.current</h4>

<p>This is a read/write property.  It returns the currently active tab.</p>

<p>Can also be used to change the currently active tabe.  You can set it to a
window (e.g. as currently returned from <code>browser.current</code>), a window name or the
tab index number.</p>

<h4>browser.tabs.dump(output)</h4>

<p>Dump a list of all open tabs to standard output, or the output stream.</p>

<h4>browser.tabs.index</h4>

<p>Returns the index of the currently active tab.</p>

<h4>browser.tabs.length</h4>

<p>Returns the number of currently opened tabs.</p>

<h4>browser.open(url: "http://example.com")</h4>

<p>Opens and returns a new tab.  Supported options are:
- <code>name</code> - Window name.
- <code>url</code> - Load document from this URL.</p>

<h4>browser.window</h4>

<p>Returns the currently active window, same as <code>browser.tabs.current.</code></p>

<h2 id="assertions">Assertions</h2>

<p>To make life easier, Zombie introduces a set of convenience assertions that you
can access directly from the browser object.  For example, to check that a page
loaded successfuly:</p>

<pre><code>browser.assert.success();
browser.assert.text("title", "My Awesome Site");
browser.assert.element("#main");
</code></pre>

<p>These assertions are available from the <code>browser</code> object since they operate on a
particular browser instance -- generally dependent on the currently open window,
or document loaded in that window.</p>

<p>Many assertions require an element/elements as the first argument, for example,
to compare the text content (<code>assert.text</code>), or attribute value
(<code>assert.attribute</code>).  You can pass one of the following values:</p>

<ul>
<li>An HTML element or an array of HTML elements</li>
<li>A CSS selector string (e.g. "h2", ".book", "#first-name")</li>
</ul>

<p>Many assertions take an expected value and compare it against the actual value.
For example, <code>assert.text</code> compares the expected value against the text contents
of one or more strings.  The expected value can be one of:</p>

<ul>
<li>A JavaScript primitive value (string, number)</li>
<li><code>undefined</code> or <code>null</code> are used to assert the lack of value</li>
<li>A regular expression</li>
<li>A function that is called with the actual value and returns true if the
assertion is true</li>
<li>Any other object will be matched using <code>assert.deepEqual</code></li>
</ul>

<p>Note that in some cases the DOM specification indicates that lack of value is an
empty string, not <code>null</code>/<code>undefined</code>.</p>

<p>All assertions take an optional last argument that is the message to show if the
assertion fails.  Better yet, use a testing framework like
<a href="http://visionmedia.github.com/mocha/">Mocha</a> that has good diff support and
don't worry about these messages.</p>

<h3 id="available_assertions">Available Assertions</h3>

<p>The following assertions are available:</p>

<h4>assert.attribute(selection, name, expected, message)</h4>

<p>Asserts the named attribute of the selected element(s) has the expected value.</p>

<p>Fails if no element found.</p>

<h4>assert.className(selection, className, message)</h4>

<p>Asserts that selected element(s) has that and only that class name.  May also be
space-separated list of class names.</p>

<p>Fails if no element found.</p>

<h4>assert.cookie(name, expected, message)</h4>

<p>Asserts that a cookie with the given name has the expected value.</p>

<h4>assert.element(selection, message)</h4>

<p>Asserts that one element matching selection exists.</p>

<p>Fails if no element or more than one matching element are found.</p>

<h4>assert.elements(selection, count, message)</h4>

<p>Asserts how many elements exist in the selection.</p>

<p>The argument <code>count</code> can be a number, or an object with the following
properties:</p>

<ul>
<li><code>atLeast</code> - Expecting to find at least that many elements</li>
<li><code>atMost</code>  - Expecting to find at most that many elements</li>
<li><code>exactly</code> - Expecting to find exactly that many elements</li>
</ul>

<h4>assert.evaluate(expression, expected, message)</h4>

<p>Evaluates the JavaScript expression in the context of the currently open window.</p>

<p>With one argument, asserts that the value is equal to <code>true</code>.</p>

<p>With two/three arguments, asserts that the returned value matches the expected
value.</p>

<h4>assert.global(name, expected, message)</h4>

<p>Asserts that the global (window) property has the expected value.</p>

<h4>assert.hasClass(selection, className, message)</h4>

<p>Asserts that selected element(s) have the expected class name.  Elements may
have other class names (unlike <code>assert.className</code>).</p>

<p>Fails if no element found.</p>

<h4>assert.hasFocus(selection, message)</h4>

<p>Asserts that selected element has the focus.</p>

<p>If the first argument is <code>null</code>, asserts that no element has the focus.</p>

<p>Otherwise, fails if element not found, or if more than one element found.</p>

<h4>assert.input(selection, expected, message)</h4>

<p>Asserts that selected input field(s) (<code>input</code>, <code>textarea</code>, <code>select</code> etc) have
the expected value.</p>

<p>Fails if no element found.</p>

<h4>assert.hasNoClass(selection, className, message)</h4>

<p>Asserts that selected element(s) does not have the expected class name.  Elements may
have other class names (unlike <code>assert.className</code>).</p>

<p>Fails if no element found.</p>

<h4>assert.prompted(messageShown, message)</h4>

<p>Asserts the browser prompted with a given message.</p>

<h4>assert.redirected(message)</h4>

<p>Asserts the browser was redirected when retrieving the current page.</p>

<h4>assert.success(message)</h4>

<p>Asserts the current page loaded successfully (status code 2xx or 3xx).</p>

<h4>assert.status(code, message)</h4>

<p>Asserts the current page loaded with the expected status code.</p>

<h4>assert.style(selection, style, expected, message)</h4>

<p>Asserts that selected element(s) have the expected value for the named style
property.  For example:</p>

<pre><code>browser.assert.style(".navigation", "opacity", 0.5)
</code></pre>

<p>Fails if no element found.</p>

<h4>assert.text(selection, expected, message)</h4>

<p>Asserts that selected element(s) have the expected text content.  For example:</p>

<pre><code>browser.assert.text("title", "My Awesome Page")
</code></pre>

<p>Fails if no element found.</p>

<h4>assert.url(url, message)</h4>

<p>Asserts the current page has the expected URL.</p>

<p>The expected URL can be one of:</p>

<ul>
<li>The full URL as a string</li>
<li>A regular expression</li>
<li>A function, called with the URL and returns true if the assertion is true</li>
<li>An object, in which case individual properties are matched against the URL</li>
</ul>

<p>For example:</p>

<pre><code>browser.assert.url("http://localhost/foo/bar")
browser.assert.url({ pathame: "/foo/bar" });
browser.assert.url({ query: { name: "joedoe" } });
</code></pre>

<h3 id="roll_your own assertions">Roll Your Own Assertions</h3>

<p>Not seeing an assertion you want?  You can add your own assertions to the
prototype of <code>Browser.Assert</code>.</p>

<p>For example:</p>

<pre><code>// Asserts the browser has the expected number of open tabs.
Browser.Assert.prototype.openTabs = function(expected, message) {
  assert.equal(this.browser.tabs.length, expected, message);
};
</code></pre>

<p>Or application specific:</p>

<pre><code>// Asserts which links is highlighted in the navigation bar
Browser.Assert.navigationOn = function(linkText) {
  this.assert.element(".navigation-bar");
  this.assert.text(".navigation-bar a.highlighted", linkText);
};
</code></pre>

<h2 id="events">Events</h2>

<p>Each browser instance is an <code>EventEmitter</code>, and will emit a variety of events
you can listen to.</p>

<p>Some things you can do with events:</p>

<ul>
<li>Trace what the browser is doing, e.g. log every page loaded, every DOM event
emitted, every timeout fired</li>
<li>Wait for something to happen, e.g. form submitted, link clicked, input element
getting the focus</li>
<li>Strip out code from HTML pages, e.g remove analytics code when running tests</li>
<li>Add event listeners to the page before any JavaScript executes</li>
<li>Mess with the browser, e.g. modify loaded resources, capture and change DOM
events</li>
</ul>

<h4>console (level, messsage)</h4>

<p>Emitted whenever a message is printed to the console (<code>console.log</code>,
<code>console.error</code>, <code>console.trace</code>, etc).</p>

<p>The first argument is the logging level, and the second argument is the message.</p>

<p>The logging levels are: <code>debug</code>, <code>error</code>, <code>info</code>, <code>log</code>, <code>trace</code> and <code>warn</code>.</p>

<h4>active (window)</h4>

<p>Emitted when this window becomes the active window.</p>

<h4>closed (window)</h4>

<p>Emitted when this window is closed.</p>

<h4>done ()</h4>

<p>Emitted when the event loop goes empty.</p>

<h4>evaluated (code, result, filename)</h4>

<p>Emitted after JavaScript code is evaluated.</p>

<p>The first argument is the JavaScript function or code (string).  The second
argument is the result.  The third argument is the filename.</p>

<h4>event (event, target)</h4>

<p>Emitted whenever a DOM event is fired on the target element, document or window.</p>

<h4>focus (element)</h4>

<p>Emitted whenever an element receives the focus.</p>

<h4>inactive (window)</h4>

<p>Emitted when this window is no longer the active window.</p>

<h4>interval (function, interval)</h4>

<p>Emitted whenever an interval (<code>setInterval</code>) is fired.</p>

<p>The first argument is the function or code to evaluate, the second argument is
the interval in milliseconds.</p>

<h4>link (url, target)</h4>

<p>Emitted when a link is clicked.</p>

<p>The first argument is the URL of the new location, the second argument
identifies the target window (<code>_self</code>, <code>_blank</code>, window name, etc).</p>

<h4>loaded (document)</h4>

<p>Emitted when a document has been loaded into a window or frame.</p>

<p>This event is emitted after the HTML is parsed, and some scripts executed.</p>

<h4>loading (document)</h4>

<p>Emitted when a document is about to be loaded into a window or frame.</p>

<p>This event is emitted when the document is still empty, before parsing any HTML.</p>

<h4>opened (window)</h4>

<p>Emitted when a new window is opened.</p>

<h4>redirect (request, response)</h4>

<p>Emitted when following a redirect.</p>

<p>The first argument is the request, the second argument is the response that
caused the redirect.  See <a href="#resources">Resources</a> for more details.</p>

<p>The URL of the new resource to retrieve is given by <code>response.url</code>.</p>

<h4>request (request)</h4>

<p>Emitted before making a request to retrieve a resource.</p>

<p>The first argument is the request object.  See <a href="#resources">Resources</a> for more
details.</p>

<h4>response (request, response)</h4>

<p>Emitted after receiving the response (excluding redirects).</p>

<p>The first argument is the request object, the second argument is the response
object.  See <a href="#resources">Resources</a> for more details.</p>

<h4>submit (url, target)</h4>

<p>Emitted whenever a form is submitted.</p>

<p>The first argument is the URL of the new location, the second argument
identifies the target window (<code>_self</code>, <code>_blank</code>, window name, etc).</p>

<h4>timeout (function, delay)</h4>

<p>Emitted whenever a timeout (<code>setTimeout</code>) is fired.</p>

<p>The first argument is the function or code to evaluate, the second argument is
the delay in milliseconds.</p>

<h2 id="resources">Resources</h2>

<p>Zombie can retrieve with resources - HTML pages, scripts, XHR requests - over
HTTP, HTTPS and from the file system.</p>

<p>Most work involving resources is done behind the scenes, but there are few
notable features that you'll want to know about. Specifically, if you need to do
any of the following:</p>

<ul>
<li>Inspect the history of retrieved resources, useful for troubleshooting issues
related to resource loading</li>
<li>Simulate a failed server</li>
<li>Change the order in which resources are retrieved, or otherwise introduce
delays to simulate a real world network</li>
<li>Mock responses from servers you don't have access to, or don't want to access
from test environment</li>
<li>Request resources directly, but have Zombie handle cookies, authentication,
etc</li>
<li>Implement new mechanism for retrieving resources, for example, add new
protocols or support new headers</li>
</ul>

<h3 id="the_resources list">The Resources List</h3>

<p>Each browser provides access to its resources list through <code>browser.resources</code>.</p>

<p>The resources list is an array of all resouces requested by the browser.  You
can iterate and manipulate it just like any other JavaScript array.</p>

<p>Each resource provides four properties:</p>

<ul>
<li><code>request</code>   - The request object</li>
<li><code>response</code>  - The resource object (if received)</li>
<li><code>error</code>     - The error received instead of response</li>
<li><code>target</code>    - The target element or document (when loading HTML page, script,
etc)</li>
</ul>

<p>The request object consists of:</p>

<ul>
<li><code>method</code>      - HTTP method, e.g. "GET"</li>
<li><code>url</code>         - The requested URL</li>
<li><code>headers</code>     - All request headers</li>
<li><code>body</code>        - The request body can be <code>Buffer</code> or string; only applies to
POST and PUT methods</li>
<li><code>multiparty</code>  - Used instead of a body to support file upload</li>
<li><code>time</code>        - Timestamp when request was made</li>
<li><code>timeout</code>     - Request timeout (0 for no timeout)</li>
</ul>

<p>The response object consists of:</p>

<ul>
<li><code>url</code>         - The actual URL of the resource; different from request URL if
there were any redirects</li>
<li><code>statusCode</code>  - HTTP status code, eg 200</li>
<li><code>statusText</code>  - HTTP static code as text, eg "OK"</li>
<li><code>headers</code>     - All response headers</li>
<li><code>body</code>        - The response body, may be <code>Buffer</code> or string, depending on the
content type encoding</li>
<li><code>redirects</code>   - Number of redirects followed (0 if no redirects)</li>
<li><code>time</code>        - Timestamp when response was completed</li>
</ul>

<p>Request for loading pages and scripts include the target DOM element or
document. This is used internally, and may also give you more insight as to why
a request is being made.</p>

<h3 id="mocking,_failing and delaying responses">Mocking, Failing and Delaying Responses</h3>

<p>To help in testing, Zombie includes some convenience methods for mocking,
failing and delaying responses.</p>

<p>For example, to mock a response:</p>

<pre><code>browser.resources.mock("http://3rd.party.api/v1/request", {
  statusCode: 200,
  headers:    { "ContentType": "application/json" },
  body:       JSON.stringify({ "count": 5 })
})
</code></pre>

<p>In the real world, servers and networks often fail.  You can test to for these
conditions by asking Zombie to simulate a failure.  For example:</p>

<pre><code>browser.resource.fail("http://3rd.party.api/v1/request");
</code></pre>

<p>Another issue you'll encounter in real-life applications are network latencies.
When running tests, Zombie will request resources in the order in which they
appear on the page, and likely receive them from the local server in that same
order.</p>

<p>Occassionally you'll need to force the server to return resources in a different
order, for example, to check what happens when script A loads after script B.
You can introduce a delay into any response as simple as:</p>

<pre><code>browser.resources.delay("http://3d.party.api/v1/request", 50);
</code></pre>

<h3 id="the_pipeline">The Pipeline</h3>

<p>Zombie uses a pipeline to operate on resources.  You can extend that pipeline
with your own set of handlers, for example, to support additional protocols,
content types, special handlers, better resource mocking, etc.</p>

<p>The pipeline consists of a set of handlers.  There are two types of handlers:</p>

<p>Functions with two arguments deal with requests.  They are called with the
request object and a callback, and must call that callback with one of:</p>

<ul>
<li>No arguments to pass control to the next handler</li>
<li>An error to stop processing and return that error</li>
<li><code>null</code> and the response objec to return that response</li>
</ul>

<p>Functions with three arguments deal with responses.  They are called with the
request object, response object and a callback, and must call that callback with
one of:</p>

<ul>
<li>No arguments to pass control to the next handler</li>
<li>An error to stop processing and return that error</li>
</ul>

<p>To add a new handle to the end of the pipeline:</p>

<pre><code>browser.resources.addHandler(function(request, next) {
  // Let's delay this request by 1/10th second
  setTimeout(function() {
    Resources.httpRequest(request, next);
  }, Math.random() * 100);
});
</code></pre>

<p>If you need anything more complicated, you can access the pipeline directly via
<code>browser.resources.pipeline</code>.</p>

<p>You can add handlers to all browsers via <code>Browser.Resources.addHandler</code>.  These
handlers are automatically added to every new <code>browser.resources</code> instance.</p>

<pre><code>Browser.Resources.addHandler(function(request, response, next) {
  // Log the response body
  console.log("Response body: " + response.body);
  next();
});
</code></pre>

<p>When handlers are executed, <code>this</code> is set to the browser instance.</p>

<h3 id="operating_on resources">Operating On Resources</h3>

<p>If you need to retrieve of operate on resources directly, you can do that as
well, using all the same features available to Zombie, including mocks, cookies,
authentication, etc.</p>

<h4>resources.addHandler(handler)</h4>

<p>Adds a handler to the pipeline of this browser instance.  To add a handler to the
pipeline of every browser instance, use <code>Browser.Resources.addHandler</code>.</p>

<h4>resources.delay(url, delay)</h4>

<p>Retrieve the resource with the given URL, but only after a delay.</p>

<h4>resources.dump(output)</h4>

<p>Dumps the resources list to the output stream (defaults to standard output
stream). </p>

<h4>resources.fail(url, error)</h4>

<p>Do not attempt to retrieve the resource with the given URL, but act as if the
request failed with the given message.</p>

<p>This is used to simulate network failures (can't resolve hostname, can't make
connection, etc).  To simulate server failures (status codes 5xx), use
<code>resources.mock</code>.</p>

<h4>resources.pipeline</h4>

<p>Returns the current pipeline (array of handlers) for this browser instance.</p>

<h4>resources.get(url, callback)</h4>

<p>Retrieves a resource with the given URL and passes response to the callback.</p>

<p>For example:</p>

<pre><code>browser.resources.get("http://some.service", function(error, response) {
  console.log(response.statusText);
  console.log(response.body);
});
</code></pre>

<h4>resources.mock(url, response)</h4>

<p>Do not attempt to retrieve the resource with the given URL, but return the
response object instead.</p>

<h4>resources.post(url, options, callback)</h4>

<p>Posts a document to the resource with the given URL and passes the response to
the callback.</p>

<p>Supported options are:</p>

<ul>
<li><code>body</code>- Request document body</li>
<li><code>headers</code> - Headers to include in the request</li>
<li><code>params</code> - Parameters to pass in the document body</li>
<li><code>timeout</code> - Request timeout in milliseconds (0 or <code>null</code> for no timeout)</li>
</ul>

<p>For example:</p>

<pre><code>var params  = { "count": 5 };
browser.resources.post("http://some.service", { params: params }, function(error, response) {
  . . .
});

var headers = { "Content-Type": "application/x-www-form-urlencoded" };
browser.resources.post("http://some.service", { headers: headers, body: "count=5" }, function(error, response) {
   . . .
});
</code></pre>

<h4>resources.request(method, url, options, callback)</h4>

<p>Makes an HTTP request to the resource and passes the response to the callback.</p>

<p>Supported options are:</p>

<ul>
<li><code>body</code>- Request document body</li>
<li><code>headers</code> - Headers to include in the request</li>
<li><code>params</code> - Parameters to pass in the query string (<code>GET</code>, <code>DELETE</code>) or
document body (<code>POST</code>, <code>PUT</code>)</li>
<li><code>timeout</code> - Request timeout in milliseconds (0 or <code>null</code> for no timeout)</li>
</ul>

<p>For example:</p>

<pre><code>browser.resources.request("DELETE", "http://some.service", function(error) {
  . . .
});
</code></pre>

<h4>resources.restore(url)</h4>

<p>Reset any special resource handling from a previous call to <code>delay</code>, <code>fail</code> or
<code>mock</code>.</p>

    </div>
  </body>
</html>
