<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\classes\HtmlElements\Tag\Table.js - Newsletter API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..\images\logo.png" title="Newsletter API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.6</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CDownload.html">CDownload</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/CellProperties.html">CellProperties</a></li>
            
                <li><a href="../classes/CImage.html">CImage</a></li>
            
                <li><a href="../classes/CKEDITOR.html">CKEDITOR</a></li>
            
                <li><a href="../classes/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../classes/CLink.html">CLink</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/Controller.html">Controller</a></li>
            
                <li><a href="../classes/Converter.html">Converter</a></li>
            
                <li><a href="../classes/ConverterElastic.html">ConverterElastic</a></li>
            
                <li><a href="../classes/ConverterFixed.html">ConverterFixed</a></li>
            
                <li><a href="../classes/ConverterGeneral.html">ConverterGeneral</a></li>
            
                <li><a href="../classes/ConverterSimpleText.html">ConverterSimpleText</a></li>
            
                <li><a href="../classes/CTable.html">CTable</a></li>
            
                <li><a href="../classes/Document.html">Document</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/EHToolbar.html">EHToolbar</a></li>
            
                <li><a href="../classes/Factory.html">Factory</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/ImageProperties.html">ImageProperties</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/LinkDialog.html">LinkDialog</a></li>
            
                <li><a href="../classes/LinkProperties.html">LinkProperties</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemProperties.html">ListItemProperties</a></li>
            
                <li><a href="../classes/ListProperties.html">ListProperties</a></li>
            
                <li><a href="../classes/Mapper.html">Mapper</a></li>
            
                <li><a href="../classes/NEWSLETTER.html">NEWSLETTER</a></li>
            
                <li><a href="../classes/OList.html">OList</a></li>
            
                <li><a href="../classes/PlainText.html">PlainText</a></li>
            
                <li><a href="../classes/Properties.html">Properties</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/RowProperties.html">RowProperties</a></li>
            
                <li><a href="../classes/Save.html">Save</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/table2ModifyDialog.html">table2ModifyDialog</a></li>
            
                <li><a href="../classes/TableDialog.html">TableDialog</a></li>
            
                <li><a href="../classes/TableProperties.html">TableProperties</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/UList.html">UList</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
                <li><a href="../classes/Worker.html">Worker</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../modules/Config.html">Config</a></li>
            
                <li><a href="../modules/Controllers.html">Controllers</a></li>
            
                <li><a href="../modules/Converter.html">Converter</a></li>
            
                <li><a href="../modules/Dialogs.html">Dialogs</a></li>
            
                <li><a href="../modules/Document.html">Document</a></li>
            
                <li><a href="../modules/EventHandler.html">EventHandler</a></li>
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Plugins.html">Plugins</a></li>
            
                <li><a href="../modules/Properties.html">Properties</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\classes\HtmlElements\Tag\Table.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint white: false */
/*jslint plusplus: true, white: true */
/*global Properties, Cell, Helper, TableProperties, Properties, Row, Tag, Content, RowProperties, CellProperties, NEWSLETTER, Unit */

/**
* Represents table.
*
* Table might be a plain one or a framed one. Table is called framed if each of its rows contains only one cell,
* and each of these cells contains another table. These three elements - row, cell and table - are called phantom ones.
* Only {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} of the phantom elements are of interest.
*
* Below it is depicted a framed table. Dotted lines correspond to the phantom elements, solid - to &quot;normal&quot; ones.
* &lt;span style=&quot;color: black&quot;&gt;Black color corresponds to table&lt;/span&gt;,
* &lt;span style=&quot;color: orange&quot;&gt;orange - to table row&lt;/span&gt;,
* &lt;span style=&quot;color: green&quot;&gt;green - to table cell&lt;/span&gt;.
* &lt;style&gt;
* .phantom, .normal{
*	border-width: 2px;
*	padding: 4px;
* 	margin: 4px;
*	border-collapse: separate;
* }
*
* .phantom {
* 	border-style: dashed;
* }
* .normal {
*   border-style: solid;
* }
* table.phantom, table.normal {
*	border-color: #2818B1;
*	padding: 10px;
* }
* td.phantom, td.normal{
* 	border-color: #00A779;
* }
* tr.phantom, tr.normal {
* 	outline-width: 2px;
* 	outline-color: #FF9C00;
* }
* tr.phantom{
* 	outline-style: dashed;
* }
* tr.normal {
* 	outline-style: solid;
* }

* &lt;/style&gt;
*
* &lt;table class=&quot;normal&quot;&gt;
* 	&lt;tr class=&quot;phantom&quot;&gt;
*  		&lt;td class=&quot;phantom&quot;&gt;
*  			&lt;table class=&quot;phantom&quot;&gt;
*  				&lt;tr class=&quot;normal&quot;&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						first cell of the first line
*  					&lt;/td&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						second cell of the first line
*  					&lt;/td&gt;
*  				&lt;/tr&gt;
*  			&lt;/table&gt;
*  		&lt;/td&gt;
*   &lt;/tr&gt;
* 	&lt;tr class=&quot;phantom&quot;&gt;
*  		&lt;td class=&quot;phantom&quot;&gt;
*  			&lt;table class=&quot;phantom&quot;&gt;
*  				&lt;tr class=&quot;normal&quot;&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						first cell of the second line
*  					&lt;/td&gt;
*  					&lt;td class=&quot;normal&quot;&gt;
*  						second cell of the second line
*  					&lt;/td&gt;
*  				&lt;/tr&gt;
*  			&lt;/table&gt;
*  		&lt;/td&gt;
*   &lt;/tr&gt;
* &lt;/table&gt;
* @module        HtmlElements
* @class         Table
* @constructor
* @extends       Tag
*/
function Table() {
	&quot;use strict&quot;;
	if (!(this instanceof Table)) {
		return new Table();
	}
	// inherit tag properties
	Tag.call(this);


	/**
	 * Re-set private properties defined in parent class {{#crossLink &quot;Tag&quot;}}Tag{{/crossLink}}:
	 * &lt;ol&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/tag:property&quot;}}tag{{/crossLink}} to be &quot;table&quot;
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/className:property&quot;}}className{{/crossLink}} to be &quot;Table&quot;
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/styles:property&quot;}}styles{{/crossLink}} to be
	 * {{#crossLink &quot;TableStyles&quot;}}TableStyles{{/crossLink}}
	 * &lt;/li&gt;&lt;li&gt;
	 * {{#crossLink &quot;Tag/attributes:property&quot;}}styles{{/crossLink}} to be
	 * {{#crossLink &quot;TableAttributes&quot;}}TableAttributes{{/crossLink}}
	 * &lt;/li&gt;&lt;/ol&gt;
	 * @method         constructor
	 */
	this.setTag(&#x27;table&#x27;);
	this.setName(&#x27;Table&#x27;);
	this.setProperties(new TableProperties());


	/**
	 * Phantom cell.
	 * @property       {Cell}    phantomCell
	 * @type           {Cell}
	 * @private
	 * @default        undefined
	 */
	var phantomCell;

	/**
	 * Phantom row.
	 * @property       {Row}    phantomRow
	 * @type           {Row}
	 * @private
	 * @default        undefined
	 */
	var phantomRow;


	/**
	 * Phantom table {{#crossLink &quot;Styles&quot;}}styles{{/crossLink}}.
	 * @property       {Table}    phantomTable
	 * @type           {Table}
	 * @private
	 * @default        undefined
	 */
	var phantomTable;

	/**
	 * Initializes {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}} if not initialized.
	 * If they are initialized, no re-initialization happens.
	 * @method          initPhantoms
	 * @return          void
	 */
	this.initPhantoms = function(){
		if (!(phantomRow instanceof Row)){
			phantomRow = new Row();
		}
		if (!(phantomCell instanceof Cell)){
			phantomCell = new Cell();
		}
		if (!(phantomTable instanceof Table)){
			phantomTable = new Table();
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomCellStyles{{/crossLink}} getter.
	 * @method         getPhantomCellStyles
	 * @return         {Styles}
	 */
	this.getPhantomCellStyles = function(){
		if (phantomCell instanceof Cell){
			return phantomCell.getStyles();
		}

	};

	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomCellStyles{{/crossLink}} setter.
	 * @method         setPhantomCellStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomCellStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Properties){
				phantomCell.setStyles(stl);
			} else {
				phantomCell.setStyles(new Properties(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomCellStyles:property&quot;}}phantomRowStyles{{/crossLink}} getter.
	 * @method         getPhantomRowStyles
	 * @return         {Styles}
	 */
	this.getPhantomRowStyles = function(){
		if (phantomRow instanceof Row){
			return phantomRow.getStyles();
		}
	};

	/**
	 * {{#crossLink &quot;Table/phantomRowStyles:property&quot;}}setPhantomRowStyles{{/crossLink}} setter.
	 * @method         setPhantomRowStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomRowStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Properties){
				phantomRow.setStyles(stl);
			} else {
				phantomRow.setStyles(new Properties(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;Table/phantomTableStyles:property&quot;}}phantomTableStyles{{/crossLink}} getter.
	 * @method         getPhantomTableStyles
	 * @return         {Styles}
	 */
	this.getPhantomTableStyles = function(){
		if (phantomTable instanceof Table){
			return phantomTable.getStyles();
		}
	};

	/**
	 * {{#crossLink &quot;Table/phantomTableStyles:property&quot;}}phantomTableStyles{{/crossLink}} setter.
	 * @method         setPhantomTableStyles
	 * @param          {Any}             stl
	 * @return         {void}
	 */
	this.setPhantomTableStyles = function(stl){
		if (stl !== undefined){
			this.initPhantoms();
			if (stl instanceof Properties){
				phantomTable.setStyles(stl);
			} else {
				phantomTable.setStyles(new Properties(stl));
			}
		}
	};


	/**
	 * {{#crossLink &quot;FramedTable/phantomCellAttributes:property&quot;}}phantomCellAttributes{{/crossLink}} getter.
	 * @method         getPhantomCellAttributes
	 * @return         {Properties}
	 */
	this.getPhantomCellAttributes = function(){
		if (phantomCell instanceof Cell){
			return phantomCell.getProperties();
		}

	};

	/**
	 * {{#crossLink &quot;FramedTable/phantomCellAttributes:property&quot;}}phantomCellAttributes{{/crossLink}} setter.
	 * @method         setPhantomCellAttributes
	 * @param          {Properties}             prop
	 * @return         {void}
	 */
	this.setPhantomCellAttributes = function(prop){
		this.initPhantoms();
		phantomCell.setProperties(prop);
	};

	/**
	 * Returns &#x60;true&#x60; if the content of the instance contains the only element
	 * which is a &quot;tbody&quot; tag instance.
	 * @method           hasTBody
	 * @return           {Boolean}
	 */
	// this.hasTBody = function(){
	// 	console.log(this.getElements());
	// 	return this.getElements().length === 1 &amp;&amp; this.getElements()[0].getTag() === &#x27;tbody&#x27;;
	// }

	/**
	 * {{#crossLink &quot;FramedTable/phantomRowAttributes:property&quot;}}phantomRowAttributes{{/crossLink}} getter.
	 * @method         getPhantomRowAttributes
	 * @return         {Properties}
	 */
	this.getPhantomRowAttributes = function(){
		if (phantomRow instanceof Row){
			return phantomRow.getProperties();
		}

	};

	/**
	 * Sets {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} of
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}}.
	 * @method         setPhantomRowProperties
	 * @param          {Properties}             prop
	 * @return         {void}
	 * @since          0.0.5
	 */
	this.setPhantomRowProperties = function(prop){
		this.initPhantoms();
		phantomRow.setProperties(prop);
	};

	/**
	 * Sets {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} of
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}}.
	 * @method         setPhantomCellProperties
	 * @param          {Properties}             prop
	 * @return         {void}
	 * @since          0.0.5
	 */
	this.setPhantomCellProperties = function(prop){
		this.initPhantoms();
		phantomCell.setProperties(prop);
	};


	/**
	 * {{#crossLink &quot;FramedTable/phantomTableAttributes:property&quot;}}phantomTableAttributes{{/crossLink}} getter.
	 * @method         getPhantomTableAttributes
	 * @return         {Properties}
	 */
	this.getPhantomTableAttributes = function(){
		if (phantomTable instanceof Table){
			return phantomTable.getProperties();
		}

	};

	/**
	 * Sets private variable {{#crossLink &quot;Tag/_property:property&quot;}}_property{{/crossLink}} of
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}}.
	 * @method         setPhantomTableProperties
	 * @param          {Any}                prop
	 * @since          0.0.5
	 * @return         {void}
	 */
	this.setPhantomTableProperties = function(prop){
		this.initPhantoms();
		phantomTable.setProperties(prop);
	};


	/**
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}}
	 * {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} getter.
	 * Alias for {{#crossLink &quot;Tag/getProperties:property&quot;}}getProperties{{/crossLink}}
	 * method.
	 * @method         getPhantomTableProperties
	 * @since          0.0.5
	 * @return         {Properties|Null}
	 */
	this.getPhantomTableProperties = function(){
		this.initPhantoms();
		return phantomTable.getProperties();

	};


	/**
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}}
	 * {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} getter.
	 * Alias for {{#crossLink &quot;Tag/getProperties:property&quot;}}getProperties{{/crossLink}}
	 * method.
	 * @method         getPhantomCellProperties
	 * @since          0.0.5
	 * @return         {Properties|Null}
	 */
	this.getPhantomCellProperties = function(){
		return phantomCell.getProperties();
	};


	/**
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}}
	 * {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} getter.
	 * Alias for {{#crossLink &quot;Tag/getProperties:property&quot;}}getProperties{{/crossLink}}
	 * method.
	 * @method         getPhantomRowProperties
	 * @since          0.0.5
	 * @return         {Properties|Null}
	 */
	this.getPhantomRowProperties = function(){
		return phantomRow.getProperties();
	};

	/**
	 * Returns {{#crossLink &quot;Tag/openingTag:method&quot;}}opening{{/crossLink}} or
	 * {{#crossLink &quot;Tag/closingTag:method&quot;}}closing{{/crossLink}} tag for one of the
	 * phantom elements: {{#crossLink &quot;Table/phantomCell:property&quot;}}cell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}row{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}table{{/crossLink}}.
	 * @method         getPhantomTag
	 * @param          {String}             phantomElem       &quot;cell&quot;, &quot;row&quot;, &quot;table&quot; (case insensitive)
	 * @param          {String|Null}        type              &quot;open&quot; or &quot;close&quot; (case insensitive).
	 *                                                        If missing, supposed to be equal to &quot;open&quot;.
	 * @return         {String}
	 */
	this.getPhantomTag = function(phantomElem, type){
		if (typeof phantomElem === &#x27;string&#x27;){
			var phElemName = phantomElem.toLowerCase(),
				tagType = (typeof type === &#x27;string&#x27; &amp;&amp; type.toLowerCase() === &#x27;close&#x27;) ? &#x27;closingTag&#x27; : &#x27;openingTag&#x27;;
			if (phElemName === &#x27;cell&#x27; &amp;&amp; phantomCell !== undefined &amp;&amp; typeof phantomCell[tagType] === &#x27;function&#x27;) {
				return phantomCell[tagType]();
			}
			if (phElemName === &#x27;row&#x27; &amp;&amp; phantomRow !== undefined &amp;&amp; typeof phantomRow[tagType] === &#x27;function&#x27;) {
				return phantomRow[tagType]();
			}
			if (phElemName === &#x27;table&#x27; &amp;&amp; phantomTable !== undefined &amp;&amp; typeof phantomTable[tagType] === &#x27;function&#x27;) {
				return phantomTable[tagType]();
			}
		}
	};


	/**
	 * The number of the rows in the table. It scans {{#crossLink &quot;Table/content:property&quot;}}content{{/crossLink}}
	 * of the instance until the first occurrence of &#x60;tbody&#x60; tag. Once found, its length is returned. If not found,
	 * zero is returned.
	 * @method  rowNum
	 * @return {Number}
	 */
	this.rowNum = function(){
		var cntn = this.getBody();
		return cntn ? cntn.length : 0;
	};

	/**
	 * Sets &#x60;tbody&#x60; part of the table. The argument must be either a {{#crossLink &quot;Row&quot;}}Row{{/crossLink}}
	 * instance or an array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances.
	 * Otherwise, an error is thrown.
	 *
	 * Even though not more than one instance of &#x60;tbody&#x60; must be present among
	 * {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}}
	 * {{#crossLink &quot;Content/elements:property&quot;}}elements{{/crossLink}}, all &#x60;tbody&#x60; tags are first dropped
	 * from {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}} and then the requested one is inserted.
	 * @method         setBody
	 * @param          {array|Row}  body    array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances or
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instance
	 * @return         {void}
	 * @since          0.0.5
	 */
	this.setBody = function(body){
		var bodyArr = Array.isArray(body) ? body : [body],
			valid;
		valid = bodyArr.every(function(elem){
			return (elem instanceof Row);
		});

		if (!valid){
			throw new Error(&#x27;Instance of Row class is required to be set as tbody!&#x27;);
		}
		var cntn = this.getContent(),
			oldTBodyPos = cntn.findTagPos(&#x27;tbody&#x27;),
			newTbody = new Tag(&#x27;tbody&#x27;);
		newTbody.setElements(bodyArr);
		if (oldTBodyPos.length &gt; 0){
			oldTBodyPos.sort(function(a, b){return b - a;});  // sort elements in descreasing order
			oldTBodyPos.forEach(function(pos){
				cntn.dropElemAt(pos);
			});
		}
		cntn.appendElem(newTbody);
		this.setContent(cntn);
	};


	/**
	 * Alias for {{#crossLink &quot;Table/setBody:method&quot;}}setBody{{/crossLink}} method.
	 *
	 * Overrides parent method {{#crossLink &quot;Tag/setElements:method&quot;}}setElements{{/crossLink}}.
	 * @method         setElements
	 * @param          {array|Row}  elems    array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances or
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instance
	 */
	this.setElements = function(elems){
		this.setBody(elems);
	};

	/**
	 * Returns array of {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances in &#x60;tbody&#x60; part of the table.
	 * @method         getBody
	 * @return         {Array}              one dimensional array of
	 *                                      {{#crossLink &quot;Row&quot;}}Row{{/crossLink}} instances
	 *                                      or empty array
	 * @since          0.0.5
	 */
	this.getBody = function(){
		var cntn = this.getContent(),
			tbody = cntn.getFirstEntryOfTag(&#x27;tbody&#x27;);
		return tbody ? tbody.getElements() : [];
	};

	/**
	 * Returns footer of the table.
	 * @method         getFooter
	 * @return         {Tag|Null}
	 */
	this.getFooter = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;tfoot&#x27;);
		}
	};

	/**
	 * Returns header of the table.
	 * @method         getHeader
	 * @return         {Tag|Null}
	 */
	this.getHeader = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;thead&#x27;);
		}
	};

	/**
	 * Returns header of the table.
	 * @method         getCaption
	 * @return         {Tag|Null}
	 */
	this.getCaption = function(){
		var cntn = this.getContent();
		if (cntn){
			return cntn.getFirstEntryOfTag(&#x27;caption&#x27;);
		}
	};

	/**
	 * Appends a row to the content property. If the argument is not a Row instance, an error is thrown.
	 * @method   appendRow
	 * @param    {Object} row     a row to append. If not a Row instance, an error is thrown.
	 * @return   {void}
	 */
	this.appendRow = function(row){
		if (!(row instanceof Row)){
			throw new Error(&#x27;The argument is not a Row instance!&#x27;);
		}
		var cntn = this.getContent(),
			tbody = cntn.getFirstEntryOfTag(&#x27;tbody&#x27;);
		if (tbody){
			tbody.appendElem(row);
			// this.
		} else {
			tbody = new Tag(&#x27;tbody&#x27;);
			tbody.setElements([row]);
			cntn.appendElem(tbody);
		}
		// cntn.filterOut(function(el){return elem.getTag() === &#x27;tbody&#x27;;});
		this.setContent(cntn);
	};

	/**
	 * Gives a two-dimensional array [[w_11, w_12, ...., w_1n], ...., [w_m1, w_m2, ...., w_m3]]
	 * where w_ij is width of the cell located in the row i and column j.
	 * @method  getMatrix
	 * @return {Array}
	 */
	this.getMatrix = function(){
		var output = [],
			rowsNum = this.rowNum(), i,
			body = this.getBody();
		for (i = 0; i &lt; rowsNum; i++){
			output.push(body[i].getCellWidths());
		}
		//console.log(&#x27;Table::getMatrix() returning &#x27;, output);
		return output;
	};

	/**
	 * Returns array of widths of the cells in the table rows if all rows
	 * have the same cell widths. Otherwise null is returned.
	 * @method  getProfile
	 * @return {Array|Null}
	 */
	this.getProfile = function (){
		var output = this.isSameWidths() ? this.getMatrix()[0] : null;
		//console.log(&#x27;Table::getProfile() returning &#x27;, output);
		return output;
	};

	/**
	 * Imposes the widths of all cell in all rows of the table body. If the argument is not array, an error is thrown.
	 * If the array length is different from the number of columns, an error is thrown. Otherwise, it is called
	 * method {{#crossLink &quot;Row/setCellWidths:method&quot;}}setCellWidths{{/crossLink}} on each row of table body.
	 * @method         setProfile
	 * @param          {Array}         profile      an array of cell widths that will be applied to each row.
	 * @return         {void}
	 */
	this.setProfile = function(profile){
		var len = this.rowNum(),
			cols = this.colNum(),
			i;
		if (!Array.isArray(profile)){
			throw new Error(&#x27;Wrong argument type: array expected.&#x27;);
		}
		if (profile.length !== cols){
			throw new Error(&#x27;Wrong input array length!&#x27;);
		}
		var tbody = this.getBody();
		for (i = 0; i &lt; len; i++){
			tbody[i].setCellWidths(profile);
		}
		this.setBody(tbody);
	};

	/**
	 * Inserts a cell &quot;cell&quot; into a given position &quot;pos&quot; of each row of the table.
	 * If the table has 5 columns, then after insertion it will have 5+1=6 columns.
	 * Position &quot;pos&quot; will correspond to the index of the inserted cell in the row after insertion.
	 * &quot;pos&quot; must be a valid cell number into the table after insertion. So, for the example above,
	 * the valid values for &quot;pos&quot; are 0, 1, 2, 3, 4 and 5.
	 * @method insertColAt
	 * @param  {Cell} 	cell
	 * @param  {Number} pos
	 * @return {void}
	 */
	this.insertColAt = function(pos, cell){
		cell = cell || (new Cell());
		var colNum = this.colNum(),
			rowNum = this.rowNum(),
			tbody = this.getBody(),
			i;

		if (colNum &lt;= 0 || pos &lt; 0 || pos &gt; colNum){
			throw new Error(&#x27;Wrong index for the cell to insert!&#x27;);
		}
		if (pos &lt; colNum){
			for (i = 0; i &lt; rowNum; i++){
				tbody[i].insertCellAt(pos, cell);
			}
		} else {
			for (i = 0; i &lt; rowNum; i++){
				tbody[i].appendCell(cell);
			}
		}
		this.setBody(tbody);

		return null;
	};


	/**
	 * Knocks out given column from the table. The operation is delegated to
	 * {{#crossLink &quot;Row/knockOutCell:method&quot;}}Row::knockOutCell{{/crossLink}} method.
	 * @method         knockOutCol
	 * @param          {integer} 	   colNum        the number of the column to be knocked out. Numeration starts with 0.
	 * @return         {void}
	 */
	this.knockOutCol = function(colNum){
		var rowsNum = this.rowNum(),
			tbody = this.getBody(),
			i;
		for (i = 0; i &lt; rowsNum; i++){
			tbody[i].knockOutCell(colNum);
		}
		this.setBody(tbody);
	};


	/**
	 * Drops specified column from the table. The operation is delegated to the &#x60;Row::dropCellAt()&#x60;
	 * @method dropColAt
	 * @param  {integer} 	colNum           the number of the column to delete. Numeration starts with 0.
	 * @return {void}
	 */
	this.dropColAt = function(colNum){
		var rowsNum = this.rowNum(),
			tbody = this.getBody(),
			i;
		for (i = 0; i &lt; rowsNum; i++){
			tbody[i].dropCellAt(colNum);
		}
		this.setBody(tbody);
	};

	/**
	 * Gives the number of columns in the table or null if not all rows have the same number of cells.
	 * The operation is delegated to the &#x60;Row::cellNum()&#x60;.
	 * @method  colNum
	 * @return {Number|null}
	 */
	this.colNum = function(){
		var rowNum = this.rowNum(),
			firstRowCellNum, i, tbody;
		// if table has no rows, return 0 as number of column
		if (rowNum === 0){
			return 0;
		}
		tbody = this.getBody();
		firstRowCellNum = tbody[0].cellNum();
		// if the table has a unique row
		if (rowNum === 1){
			return firstRowCellNum;
		}

		for (i = 1; i &lt; rowNum; i++){
			if (tbody[i].cellNum() !== firstRowCellNum){
				return null;
			}
		}
		return firstRowCellNum;
	};

	/**
	 * Whether all rows in the table have the same cell widths.
	 * @method isSameWidth
	 * @return {Boolean} true, if all rows have the same cells&#x27; widths, false otherwise.
	 */
	this.isSameWidths = function(){
		var matrix = this.getMatrix(),
			rowsNum = matrix.length,
			output = true,
			firstRow, firstRowLen, i, j;
			//console.log(&#x27;table::isSameWidth: matrix=&#x27;, matrix);
		// only if the number of rows is bigger than 1
		if (rowsNum &gt; 1){
			// compare the first row with the rest
			firstRow = matrix[0];
			firstRowLen = firstRow.length;
			for (i = 1; i &lt; rowsNum; i++){
				if (matrix[i].length !== firstRowLen){
					output = false;
					break;
				}
				// compare element by element
				for (j = 0; j &lt; firstRowLen; j++){
					if(matrix[i][j] !== firstRow[j]){
						output = false;
						break;
					}
				}
				// exit as well from outer loop if necessary
				if (!output){
					break;
				}
			}
		}
		return output;
	};

	/**
	 * Set the border of the table.
	 *
	 * It gets a copy of current {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}}, applies
	 * {{#crossLink &quot;Properties/setBorder:method&quot;}}Properties.setBorder(){{/crossLink}} method to it and
	 * sets instance&#x27;s properties to the resulted properties.
	 * @method         setBorder
	 * @param          {Object}     borderInfo
	 * @return         {void}
	 */
	this.setBorder = function(borderInfo){
		var newProp = this.getProperties();
		newProp.setBorder(borderInfo);
		this.setProperties(newProp);
	};

	/**
	 * Returns object with information about border properties (style, width, color).
	 *
	 * It is an alias of {{#crossLink &quot;Properties/getBorder:method&quot;}}Properties.getBorder(){{/crossLink}}.
	 * @method         getBorder
	 * @return         {Object}
	 * @since          0.0.6
	 */
	this.getBorder = function(){
		return this.getProperties().getBorder();
	};

	/**
	 * Removes the border of the table.
	 *
	 * It updates {{#crossLink &quot;Tag/_properties:property&quot;}}_properties{{/crossLink}} by applying to it
	 * {{#crossLink &quot;Properties/removeBorder:property&quot;}}removeBorder{{/crossLink}} method.
	 * @method  removeBorder
	 * @return {void}
	 */
	this.removeBorder = function(){
		var newProp = this.getProperties();
		newProp.removeBorder();
		this.setProperties(newProp);
	};

	/**
	 * Returns true if the table is fragmented, and false otherwise. It takes table rows and calls method
	 * {{#crossLink &quot;Row/onlyTableInside:method&quot;}}onlyTableInside{{/crossLink}} on each of them until
	 * first &quot;false&quot; is encountered.
	 *
	 * A table is a __framed table__ if all table rows have only one cell and this cell contains
	 * only one element that is a Table instance.
	 * @method         isFragmented
	 * @return         {Boolean}            true if the table is framed, and false otherwise
	 */
	this.isFragmented = function(){
		if (this.rowNum() === 0){
			return false;
		}
		return this.getBody().every(function(row){
			var res = row.onlyTableInside();
			return res;
		});
	};

	/**
	 * Returns &#x60;true&#x60; if at least one of the following variables  {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}} is set. &#x60;False&#x60; otherwise.
	 * @method         isFramed
	 * @return         {Boolean}
	 */
	this.isFramed = function(){
		return (phantomRow !== undefined) || (phantomCell !== undefined) || (phantomTable !== undefined);
	};

	/**
	 * Unsets phantom properties. After resetting those properties, the table becomes a table without frame.
	 * @method unsetPhantom
	 * @return {void}
	 */
	this.unsetPhantom = function(){
		phantomRow = undefined;
		phantomCell = undefined;
		phantomTable = undefined;
	};

	/**
	 * Appends the style to the column. If the column exists, the method call &#x60;Row::appendStyleToCell()&#x60;
	 * on each of the table rows.
	 * @method appendStyleToCol
	 * @param  {Number}        colNum    column number to which the style is to be appended.
	 * @param  {Style|Object}  style     Style or Object to be appended
	 * @return {void}
	 */
	this.appendStyleToCol = function(colNum, style){
		var colNumInt = parseInt(colNum, 10),
			colLen = this.colNum(),
			rowLen = this.rowNum(),
			tbody = this.getBody(),
			i;
		if (colNumInt === colNum &amp;&amp; colNum &gt;= 0 &amp;&amp; colNum &lt; colLen) {
			for (i = 0; i &lt; rowLen; i++){
				tbody[i].appendStyleToCellAt(colNum, style);
			}
			this.setBody(tbody);
		} else {
			throw new Error(&#x27;The column is not present!&#x27;);
		}
	};

	/**
	 * Generates html representation of the table body. If table is framed, wraps each element of
	 * {{#crossLink &quot;Tag/content:property&quot;}}content{{/crossLink}} with strings corresponding to phantom
	 * elements. Generation of html string of each {{#crossLink &quot;Tag/content:property&quot;}}content element{{/crossLink}}
	 * is delegated to its &#x60;toHtml&#x60; method (if an element has no &#x60;toHtml&#x60; method, this element gets ignored).
	 * @method         bodyToHtml
	 * @param          {Boolean}            withFrame         whether the table is framed or not.
	 * @return         {String}
	 * @since          0.0.5
	 */
	this.bodyToHtml = function(){
		var prologue = &#x27;&#x27;,
			epilogue  = &#x27;&#x27;,
			bodyHtml = &#x27;&#x27;;
		if (this.isFramed()){
			epilogue = this.getPhantomTag(&#x27;row&#x27;, &#x27;open&#x27;) + this.getPhantomTag(&#x27;cell&#x27;, &#x27;open&#x27;) + this.getPhantomTag(&#x27;table&#x27;, &#x27;open&#x27;);
			prologue = this.getPhantomTag(&#x27;table&#x27;, &#x27;close&#x27;) + this.getPhantomTag(&#x27;cell&#x27;, &#x27;close&#x27;) + this.getPhantomTag(&#x27;row&#x27;, &#x27;close&#x27;);
		}
		this.getBody().forEach(function(el){
			if (typeof el.toHtml === &#x27;function&#x27;){
				bodyHtml += epilogue + el.toHtml() + prologue;
			}
		});
		return bodyHtml;
	};

	/**
	 * Generates html code corresponding to this instance. Makes use of
	 * {{#crossLink &quot;Table/bodyToHtml:method&quot;}}bodyToHtml{{/crossLink}} method.
	 *
	 * This method overrides parent one {{#crossLink &quot;Tag/toHtml:method&quot;}}toHtml{{/crossLink}} because one has to manage
	 * presence of properties {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}} and
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}}.
	 * @method         toHtml
	 * @return         {String}
	 */
	this.toHtml = function () {
		var tableHtml  = this.openingTag();
		var that = this;

		this.getElements().forEach(function(el){
			if (typeof el.toHtml === &#x27;function&#x27;){
				if (el.getTag() === &#x27;tbody&#x27;){
					tableHtml += el.openingTag() + that.bodyToHtml() + el.closingTag();
				} else {
					tableHtml += el.toHtml();
				}

			}
		});
		tableHtml += this.closingTag();
		return tableHtml;
	};


	/**
	 * Generates instance of [DOM.Element](https://developer.mozilla.org/en-US/docs/Web/API/element)
	 * corresponding to this instance.
	 *
	 * This method overrides parent one  {{#crossLink &quot;Tag/toNode:method&quot;}}toNode{{/crossLink}} because
	 * one has to manage presence of properties {{#crossLink &quot;Table/phantomTable:property&quot;}}phantomTable{{/crossLink}},
	 * {{#crossLink &quot;Table/phantomCell:property&quot;}}phantomCell{{/crossLink}} and
	 * {{#crossLink &quot;Table/phantomRow:property&quot;}}phantomRow{{/crossLink}}.
	 * @method         toNode
	 * @return         {DOM.Element}
	 */
	this.toNode = function(){
		var el = document.createElement(this.getTag());
		this.getProperties().decorateElement(el);
		if (this.isFramed()){
			var body = this.getBody();
			body.forEach(function(row){
				var rowNode = row.toNode();
				var phantomRowNode = phantomRow.toNode();
				var phantomCellNode = phantomCell.toNode();
				var phantomTableNode = phantomTable.toNode();
				phantomRowNode.appendChild(phantomCellNode);
				phantomCellNode.appendChild(phantomTableNode);
				phantomTableNode.appendChild(rowNode);
				el.appendChild(phantomRowNode);
			});
		} else {
			this.getContent().stickTo(el);
		}
		return el;
	};


	/**
	 * If the table is fragmented and all rows have the same requested property, then
	 * this property of the first row is returned. In any other case, null is returned.
	 * NB: to compare requested property for all rows, this property must be an object
	 * with boolean-valued method isTheSameAs().
	 * @method   getPhantomRowProp
	 * @param    {String}         prop      a tag of the property to return. All rows should have this property.
	 * @return   {Object|null}			    the value of the property specified by the argument, if it is the same
	 *                                      for all rows, null otherwise.
	 */
	this.getPhantomRowProp = function(prop){
		if (!this.isFragmented()){
			return null;
		}
		var firstRow = this.getFirst(),
			rowNum = this.rowNum(),
			rowProp, i, firstRowProp;
		switch (prop){
			case &#x27;attr&#x27;:
				firstRowProp = firstRow.getProperties();
				break;
			case &#x27;style&#x27;:
				firstRowProp = firstRow.getStyles();
				break;
			default:
				return null;
		}
		if (rowNum === 1){
			return firstRowProp;
		}
		if (typeof firstRowProp.isTheSameAs !== &#x27;function&#x27;){
			return null;
		}
		for (i = 1; i &lt; rowNum; i++){
			rowProp = (prop === &#x27;style&#x27;) ? (this.getElem(i).getStyles()) : (prop === &#x27;attr&#x27; ? this.getElem(i).getProperties() : null) ;
			if (!firstRowProp.isTheSameAs(rowProp)){
				return null;
			}
		}
		return firstRowProp;

	};

	/**
	 * Gets copy of n-th row stored in table body. If that row does not exist, nothing is returned.
	 * @method        getRow
	 * @param         {Number}    n
	 * @return        {Row|Null}
	 * @since         0.0.5
	 */
	this.getRow = function(n){
		if (n !== undefined){
			var len = this.rowNum();
			if (len &gt; 0 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; len){
				return this.getBody()[n];
			}
		}
	};

	/**
	 * Returns copy of the first row stored in table body. If that row does not exist, nothing is returned.
	 * @method         getFirstRow
	 * @return         {Row}
	 * @since          0.0.5
	 */
	this.getFirstRow = function(){
		if (this.rowNum() &gt; 0){
			return this.getBody()[0];
		}
	};

	/**
	 * Returns copy of last row stored in table body. If that row does not exist, nothing is returned.
	 * @method        getLastRow
	 * @return        {Row}
	 * @since         0.0.5
	 */
	this.getLastRow = function(){
		var len = this.rowNum();
		if (len &gt; 0){
			return this.getBody()[len - 1];
		}
	};

	/**
	 * If the table is fragmented, gives the requested property of the phantom cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method        getPhantomCellProp
	 * @param         {String}              propName            requested property (supposed to be &quot;style&quot; or &quot;attr&quot;)
	 * @return        {Object|null}
	 */
	this.getPhantomCellProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getPhantomCellProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getPhantomCellProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;
	};

	/**
	 * If the table is fragmented, gives the requested property of the phantom cell if that property is
	 * the same for all rows. Otherwise, null is returned.
	 * @method  getPhantomTableProp
	 * @param   {String}     propName            requested property (supposed to be &quot;style&quot; or &quot;attr&quot;)
	 * @return  {Object|null}
	 */
	this.getPhantomTableProp = function(propName){
		if (!this.isFragmented()){
			return null;
		}
		var rowNum = this.rowNum(),
			firstRow = this.getFirst(),
			firstRowProp, i, currentRowProp;
		firstRowProp = firstRow.getPhantomTableProp(propName);
		if (rowNum === 1){
			return firstRowProp;
		}
		for (i = 1; i &lt; rowNum; i++){
			currentRowProp = this.getElem(i).getPhantomTableProp(propName);
			if (!firstRowProp.isTheSameAs(currentRowProp)){
				return null;
			}
		}
		return firstRowProp;

	};


	/**
	 * If the table is fragmented, then sets up the phantom properties and rearrange content property.
	 * If not, the table remains as it is.
	 *
	 * NB: note that disentanglement occurs of a table body only. If the table header contains a
	 * fragmented table, it remains untouched.
	 * @method   desintangle
	 * @return   {void}
	 */
	this.disentangle = function(){
		if (!this.isFragmented()){
			return null;
		}
		var rows = [],
			rowNum = this.rowNum(),
			i, firstRow, cellInside, tableInside, body;
		body = this.getBody();
		firstRow = this.getFirstRow();
		if (firstRow){
			this.setPhantomRowProperties(firstRow.getProperties());
			cellInside = firstRow.getFirst();
			if (cellInside){
				this.setPhantomCellProperties(cellInside.getProperties());
				tableInside = cellInside.getFirst();
				if (tableInside){
					this.setPhantomTableProperties(tableInside.getProperties());
					for (i = 0; i &lt; rowNum; i++){
						try {
							rows.push(body[i].getFirst().getFirst().getFirstRow());
						} catch (e){
							console.log(&#x27;Error (&#x27; + e.name + &#x27;) when retrieving nested rows &#x27; + e.message);
						}
					}
					try {
						this.setBody(rows);
					} catch (e){
						console.log(&#x27;Error (&#x27; + e.name + &#x27;) when setting table body &#x27;  + e.message);
					}

				}
			}
		}
	};



	/**
	 * Inserts &#x60;r&#x60; {{#crossLink &quot;Row&quot;}}rows{{/crossLink}} with &#x60;c&#x60; {{#crossLink &quot;Cell&quot;}}cells{{/crossLink}} each.
	 *
	 * Creating a {{#crossLink &quot;Row&quot;}}row{{/crossLink}} with &#x60;c&#x60;-many cells is delegated to
	 * {{#crossLink &quot;Row/makeShape:method&quot;}}Row.makeShape{{/crossLink}} method.
	 *
	 * Previous content of the table gets lost after execution of this method.
	 *
	 * @method         makeShape
	 * @param          {Integer}        r       number of rows
	 * @param          {Integer}        c       number of columns
	 * @param          {Function}       fun     [optional]  function to mark the rows. It will be given
	 *                                          two arguments: current row and cell numbers.
	 * @return         {void}
	 * @since          0.0.6
	 */
	this.makeShape = function(r, c, fun){
		if (r === undefined){
			throw new Error(&#x27;Number of rows and columns are missing.&#x27;);
		}
		// proceed only if both r and c are positive integer.
		if (parseInt(r, 10) !== r || r &lt;= 0){
			throw new Error(&#x27;Number of rows must be positive integer.&#x27;);
		}
		var i, row,
			needToMark = typeof fun === &#x27;function&#x27;,
			markCell;
		this.flushContent();
		for (i = 0; i &lt; r; i++){
			row = new Row();
			if (needToMark){
				markCell = function(j){
					return fun(i, j);
				};
				row.makeShape(c, markCell);
			} else {
				row.makeShape(c);
			}

			this.appendRow(row);
		}
	};


	/**
	 * Configures current {{#crossLink &quot;Table&quot;}}Table{{/crossLink}} instance
	 * using information provided by &#x60;template&#x60; object.
	 * &#x60;template&#x60; object is of format described in {{#crossLink &quot;Table/template:method&quot;}}Table::template{{/crossLink}} method.
	 * @method         configure
	 * @param          {Object}        template           json object chracterizing parameters of the table instance
	 * @param          {Function}      fun             [optional] function to be passed to
	 *                                                 {{#crossLink &quot;Table/makeShape:property&quot;}}makeShape{{/crossLink}}
	 *                                                 method.
	 * @return         {Table}
	 * @since          0.0.6
	 */
	this.configure = function(template, fun){
		this.mark(NEWSLETTER[&#x27;marker-name&#x27;]);
		if (typeof fun === &#x27;function&#x27;){
			this.makeShape(template.rows, template.cols, fun);
		} else {
			this.makeShape(template.rows, template.cols);
		}
		this.markRows(NEWSLETTER[&#x27;marker-name&#x27;]);
		// this.markCells(NEWSLETTER[&#x27;marker-name&#x27;]);
		this.configureProperties(template);
	};

	/**
	 * Marks all table rows.
	 * @method         markRows
	 * @param          {String}       marker
	 * @return         {void}
	 * @since          0.0.6
	 */
	this.markRows = function(marker){
		var r = this.rowNum(),
			i, elem,
			c = new Content();
		for (i = 0; i &lt; r; i++){
			elem = this.getElem(i);
			if (elem &amp;&amp; typeof elem.mark === &#x27;function&#x27;){
				elem.mark(marker);
				c.appendElem(elem);
			}
		}
		this.setContent(c);
	};

	/**
	 * Imposes table characteristics related to its properties (e.g., background color, border width,
	 * row/cell width) and not to its structure (number of rows and columns).
	 * @method         configureProperties
	 * @param          {Object}        descr
	 * @return         {void}
	 */
	this.configureProperties = function(descr){
		var tWidth = descr.width,
			bWidth = descr.tableBorderWidth,
			spaceBtwRows = descr.spaceBtwRows,
			currentWidth = tWidth.clone(),
			spaceBtwRowsHalf = spaceBtwRows.frac(2, 0),
			cellWidths, i;

		if (descr.spaceTableGlobal.getValue() &gt; 0){
			this.setStyleProperty(&#x27;margin&#x27;, descr.spaceTableGlobal.toString());
			currentWidth = currentWidth.sub(descr.spaceTableGlobal.times(2));
		}

		var globalPadding = descr.paddingTableGlobal;
		this.setStyleProperty(&#x27;padding&#x27;, globalPadding.toString());
		// this.setProperty(&#x27;cellpadding&#x27;, globalPadding.getValue());
		this.setProperty(&#x27;cellspacing&#x27;, globalPadding.getValue());
		currentWidth = currentWidth.sub(globalPadding.times(2));

		// setting overall border of the table
		if (bWidth.getValue() &gt; 0){
			currentWidth = currentWidth.sub(bWidth.times(2));
			this.setBorder({
				style: &#x27;solid&#x27;,
				color: descr.tableBorderColor,
				width: bWidth.getValue()
			});
		}

		// padding is always zero
		// this.setStyleProperty(&#x27;padding&#x27;, 0);
		// available width for the table after taking into account margin, padding and border widths
		this.setWidth(currentWidth.getValue());

		// setting vertical spaces between rows
		this.setStyleProperty(&#x27;border-spacing&#x27;, &#x27;0px &#x27; + spaceBtwRowsHalf.toString());

		// setting background color
		if (descr.globalTableBgColor){
			this.setStyleProperty(&#x27;background-color&#x27;, descr.globalTableBgColor);
		}

		// setting properties of the phantom elements
		if (descr.phantomBorderWidth.getValue() &gt; 0){
			var phantomRowProp    = new RowProperties(),
				phantomCellProp   = new CellProperties(),
				phantomTableProp  = new TableProperties();

			phantomRowProp.setStyleProperty(&#x27;padding&#x27;, 0);
			phantomRowProp.setStyleProperty(&#x27;margin&#x27;, 0);
			phantomCellProp.setStyleProperty(&#x27;padding&#x27;, 0);
			phantomCellProp.setStyleProperty(&#x27;margin&#x27;, 0);

			// setting width of the phantom row and phantom cell
			phantomRowProp.setWidth(currentWidth.getValue());
			phantomCellProp.setWidth(currentWidth.getValue());

			phantomTableProp.setBorder({
				style: &#x27;solid&#x27;,
				color: descr.phantomBorderColor,
				width: descr.phantomBorderWidth.getValue()
			});

			// updating current width after imposing border width of the phantom table
			currentWidth = currentWidth.sub(descr.phantomBorderWidth.times(2));
			phantomTableProp.setWidth(currentWidth.getValue());

			this.setPhantomRowProperties(phantomRowProp);
			this.setPhantomCellProperties(phantomCellProp);
			this.setPhantomTableProperties(phantomTableProp);
		}
		this.setAllRowWidths(currentWidth.getValue());
		cellWidths = Helper.columnWidths2(currentWidth.getValue(), descr.cellWeights);
		var cellBorderInfo = descr.cellBorderWidth.toString() + &#x27; solid &#x27; + descr.cellBorderColor;
		if (descr.cellBorders.topHor){
			this.setStylePropertyOfBlock(&#x27;border-top&#x27;, cellBorderInfo, [0]);
		}
		if (descr.cellBorders.bottomHor &amp;&amp; descr.rows &gt; 0){
			this.setStylePropertyOfBlock(&#x27;border-bottom&#x27;, cellBorderInfo, [descr.rows - 1]);
		}
		// horizontal border between rows: top border of each but first rows
		if (descr.cellBorders.intHor){
			// creating array [1, 2, 3, ...., row - 1]
			var rowNums = [];
			for (i = 1; i &lt; descr.rows; i++){
				rowNums.push(i);
			}
			this.setStylePropertyOfBlock(&#x27;border-top&#x27;, cellBorderInfo, rowNums);
		}
		// left border of most left cells
		if (descr.cellBorders.leftVer){
			this.setStylePropertyOfBlock(&#x27;border-left&#x27;, cellBorderInfo, null, [0]);
			// adjusting left cell width for further setting by means of &quot;setProfile&quot;
			cellWidths[0] -= descr.cellBorderWidth.getValue();

		}
		// most right border
		if (descr.cellBorders.rightVer){
			this.setStylePropertyOfBlock(&#x27;border-right&#x27;, cellBorderInfo, null, [descr.cols - 1]);
			// adjusting right cell width for further setting by means of &quot;setProfile&quot;
			cellWidths[cellWidths.length - 1] -= descr.cellBorderWidth.getValue();
		}

		// vertical border between columns: left border of each but first column
		if (descr.cellBorders.intVer){
			// creating array [1, 2, 3, ...., col - 1] of cell indexes to which border is to be applied
			// hence the width of these cells is to be adjusted.
			var colNums = [];
			for (i = 1; i &lt; descr.cols; i++){
				colNums.push(i);
				// adjusting cell width for further setting by means of &quot;setProfile&quot;
				cellWidths[i] -= descr.cellBorderWidth.getValue();
			}
			this.setStylePropertyOfBlock(&#x27;border-left&#x27;, cellBorderInfo, null, colNums);
		}
		this.setStylePropertyOfBlock(&#x27;padding&#x27;, descr.spaceCell.toString(), null, null);
		this.setProfile(cellWidths);
		// console.log(&#x27;table html after configuring properties: &#x27;, this.toHtml());
	};

	/**
	 * Table template: json object of table properties that parametrise the table. As required, overrides
	 * base class method {{#crossLink &quot;Tag/template:method&quot;}}Tag::template{{/crossLink}}.
	 *
	 * Returns an object with the following kyes:&lt;dl&gt;
	 * &lt;dt&gt;rows&lt;/dt&gt;&lt;dd&gt; (Integer) number of rows&lt;/dd&gt;
	 * &lt;dt&gt;cols&lt;/dt&gt;&lt;dd&gt; (Integer) number of columns&lt;/dd&gt;
	 * &lt;dt&gt;tableBorderWidth&lt;/dt&gt;&lt;dd&gt;(String|Number) table border width (might include unit of measurement)&lt;/dd&gt;
	 * &lt;dt&gt;tableBorderColor&lt;/dt&gt;&lt;dd&gt;(String) table border color&lt;/dd&gt;
	 * &lt;dt&gt;phantomBorderWidth&lt;/dt&gt;&lt;dd&gt;(String|Number) width of border around each row
	 * (might include unit of measurement)&lt;/dd&gt;
	 * &lt;dt&gt;phantomBorderColor&lt;/dt&gt;&lt;dd&gt; (String) color of border around each row&lt;/dd&gt;
	 * &lt;dt&gt;cellBorders&lt;dt&gt;&lt;dd&gt;(Object) object with the following keys:&lt;dl&gt;
	 * 		&lt;dt&gt;leftVer&lt;/dt&gt;&lt;dd&gt;(Boolean) whether the most left vertical border of the first cell of each row is present&lt;/dd&gt;
	 *  	&lt;dt&gt;rightVer&lt;/dt&gt;&lt;dd&gt;(Boolean) whether the most right vertical border of the last cell of each row is present&lt;/dd&gt;
	 *  	&lt;dt&gt;intVer&lt;/dt&gt;&lt;dd&gt;(Boolean) whether the inner vertical borders are present&lt;/dd&gt;
	 *  	&lt;dt&gt;topHor&lt;/dt&gt;&lt;dd&gt;(Boolean) whether the top horizontal border of each cell of the first row is present&lt;/dd&gt;
	 *  	&lt;dt&gt;bottomHor&lt;/dt&gt;&lt;dd&gt;(Boolean) whether the bottom horizontal border of each cell of the last row is present&lt;/dd&gt;
	 *  	&lt;dt&gt;intHor&lt;/dt&gt;&lt;dd&gt;(Boolean) whether inner horizontal borders are present&lt;/dd&gt;
	 * &lt;/dl&gt;&lt;/dd&gt;
	 * &lt;dt&gt;cellBorderWidth&lt;/dt&gt;&lt;dd&gt;(String|Unit) width of the border(s) mentioned in key &#x60;cellBorders&#x60;&lt;/dd&gt;
	 * &lt;dt&gt;cellBorderColor&lt;/dt&gt;&lt;dd&gt;(String) Color of the border(s) mentioned in key &#x60;cellBorders&#x60;&lt;/dd&gt;
	 * &lt;dt&gt;globalTableBgColor&lt;/dt&gt;&lt;dd&gt;(String) table background color&lt;/dd&gt;
	 * &lt;dt&gt;spaceTableGlobal&lt;/dt&gt;&lt;dd&gt;(String|Unit) table margin&lt;/dd&gt;
	 * &lt;dt&gt;paddingTableGlobal&lt;/dt&gt;&lt;dd&gt;(String|Unit) table padding &lt;/dd&gt;
	 * &lt;dt&gt;spaceBtwRows&lt;/dt&gt;&lt;dd&gt;(String) &#x60;border-spacing&#x60; of the table in the following format: &#x27;5px 6px&#x27;,
	 * 5px - horizontally, 6px - vertically    &lt;/dd&gt;
	 * &lt;dt&gt;spaceCell&lt;/dt&gt;&lt;dd&gt;(String|Unit)  &#x60;padding&#x60; of each cell&lt;/dd&gt;
	 * &lt;dt&gt;width&lt;/dt&gt;&lt;dd&gt;(String|Unit) table width&lt;/dd&gt;
	 * &lt;/dl&gt;
	 * @method         template
	 * @return         {Object}
	 * @since          0.0.7
	 */
	this.template = function(){
		var cellBorders = this.getCellBorders(),
			tableBorderInfo = this.getBorder() || {};
		var tableInfo = {
			rows:                 this.rowNum(),
			cols:                 this.colNum(),
			tableBorderWidth:     tableBorderInfo.width,
			tableBorderColor:     tableBorderInfo.color,
			phantomBorderWidth:   this.getPhantomTableProperties().getBorder().width,
			phantomBorderColor:   this.getPhantomTableProperties().getBorder().color,
			cellBorders: {
				leftVer:   cellBorders.leftVer,
				rightVer:  cellBorders.rightVer,
				intVer:    cellBorders.intVer,
				topHor:    cellBorders.topHor,
				bottomHor: cellBorders.bottomHor,
				intHor:    cellBorders.intHor,
			},
			// zero apprx for cell border width. Use info about all table cells and not only the first row cells!
			cellBorderWidth:    cellBorders.width,
			cellBorderColor:    cellBorders.color,
			globalTableBgColor: this.getStyleProperty(&#x27;background-color&#x27;),
			spaceTableGlobal:   this.getStyleProperty(&#x27;margin&#x27;),
			paddingTableGlobal: this.getStyleProperty(&#x27;padding&#x27;),
			spaceBtwRows:       this.getStyleProperty(&#x27;border-spacing&#x27;).split(&#x27; &#x27;).pop(),
			spaceCell:          this.getStylePropertyOfBlock(&#x27;padding&#x27;, null, null),
			width:              this.getWidth(),
			cellWeights:        this.getProfile()
		};
		return tableInfo;

	};

	/**
	 * Sets style property &#x60;key&#x60; of children with numbers that are in array &#x60;cellArr&#x60; of rows
	 * with numbers that are in array &#x60;rowArr&#x60; to be equal to &#x60;value&#x60;.
	 *
	 * Example, &lt;code&gt;table.setStylePropertyOfBlock(&#x27;padding&#x27;, &#x27;1em&#x27;, [1, 3, 5], [2, 8, 12])&lt;/code&gt;
	 * imposes inline style &#x60;padding&#x60; to be &#x60;1em&#x60; to cells with numbers 2, 8, 12 of rows with numbers 1, 3, and 5.
	 *
	 * @method         setStylePropertyOfBlock
	 * @param          {Array|Null}    rowArr    array of integers indicating row numbers
	 * @param          {Array|Null}    cellArr   array of integers indicating cell numbers
	 * @param          {String}        key       name of style property to set (e.g., &quot;width&quot;, &quot;padding&quot; etc)
	 * @param          {String}        value     border description (e.g., &quot;1px solid red&quot;)
	 * @return         {void}
	 * @since          0.0.6
	 */
	this.setStylePropertyOfBlock = function(key, value, rowArr, cellArr){
		if (!Array.isArray(rowArr) &amp;&amp; rowArr !== null &amp;&amp; rowArr !== undefined){
			throw new Error(&#x27;Row range must be an array!&#x27;);
		}
		var body = this.getBody(),
			newBody = [],
			rowNum = body.length,
			row, r,
			setForAll = (rowArr === null || rowArr === undefined); // in case the range is not specified, apply for all rows
		for (r = 0; r &lt; rowNum; r++){
			row = body[r];
			if (setForAll || rowArr.indexOf(r) !== -1){
				row.setStylePropertyOfRange(key, value, cellArr);
			}
			newBody.push(row);
		}
		this.setBody(newBody);
	};

	/**
	 * Sets width of all rows of the table.
	 *
	 * It calls {{#crossLink &quot;Tag/setWidth:method&quot;}}setWidth{{/crossLink}} method on each row.
	 * @method         setAllRowWidths
	 * @param          {String|Number}   w        width value
	 * @return         {void }
	 * @since          0.0.6
	 */
	this.setAllRowWidths = function(w){
		// interrupt if the argument is neither string nor number
		if (typeof w !== &#x27;string&#x27; &amp;&amp; typeof w !== &#x27;number&#x27;){
			throw new Error(&#x27;Width must be a string or a number!&#x27;);
		}
		var body = this.getBody(),
			newBody = [],
			rowNum = body.length,
			row, r;
		for (r = 0; r &lt; rowNum; r++){
			row = body[r];
			row.setWidth(w);
			newBody.push(row);
		}
		this.setBody(newBody);
	};

	/**
	 * Returns value of style property &#x60;key&#x60; of rows which indexes are in array &#x60;rowArr&#x60; and cell
	 * indexes are in array &#x60;cellArr&#x60; if all objects have the same value of the above property.
	 * Otherwise, &#x60;null&#x60; is returned.
	 *
	 * &#x60;rowArr&#x60; array admits negative values (with usual meaning: enumeration starts from the end).
	 *
	 * @method         getStylePropertyOfBlock
	 * @param          {String}        key       name of style property (e.g., &quot;width&quot;, &quot;top-border&quot;)
	 * @param          {Array|null}    rowArr    array of row indexes (or null for all rows)
	 * @param          {Array|null}    cellArr   array of column indexes (or null for all rows)
	 * @return         {String|null}
	 * @since          0.0.6
	 */
	this.getStylePropertyOfBlock = function(key, rowArr, cellArr){
		if (!Array.isArray(rowArr) &amp;&amp; rowArr !== null &amp;&amp; rowArr !== undefined){
			throw new Error(&#x27;Row range must be an array!&#x27;);
		}
		var body = this.getBody(),
			rowNum = body.length,
			row, r,
			value, currentValue,
			checkForAll = (rowArr === null || rowArr === undefined); // in case the range is not specified, apply for all rows
		// if one needs to consider elements one by one from rowArr,
		// replace negative elements (if any) by corresponding positive ones
		if (!checkForAll){
			rowArr = rowArr.map(function(i){return i &lt; 0 ? rowNum + i : i;});
		}
		for (r = 0; r &lt; rowNum; r++){
			if (checkForAll || rowArr.indexOf(r) !== -1){
				row = body[r];
				currentValue = row.getStylePropertyOfRange(key, cellArr);
				if (value === undefined){
					// initialize value
					value = currentValue;
				} else {
					// exit, if already initialized value is different from current value
					if (value !== currentValue){
						return;
					}
				}
			}
		}
		return value;
	};

	/**
	 * Updates &#x60;tableNode&#x60; with new chracteristics given by &#x60;tableInfo&#x60; object.
	 *
	 * It takes &#x60;tableNode&#x60;, constructs {{#crossLink &quot;Table&quot;}}Table{{/crossLink}} instance of it,
	 * adjusts its properties according to &#x60;tableInfo&#x60; and returns it.
	 * @method         update
	 * @param          {Table}         tableNode
	 * @param          {Object}        dialogData
	 * @return         {Table}         a Table instance with updated properties
	 */
	this.update = function(tableInfo){
		var tableClone = this.clone();
		tableClone.configureProperties(tableInfo);
		return tableClone;
	};

	/**
	 * Returns {{#crossLink &quot;Table/getStylePropertyOfBlock:method&quot;}}getStylePropertyOfBlock(){{/crossLink}} output
	 * formatted as {{#crossLink &quot;Properties/getBorder:method&quot;}}border info object{{/crossLink}}.
	 * @method         getStylePropertyOfRangeAsBorderInfo
	 * @param          {String}        key
	 * @param          {Array|null}    rowArr
	 * @param          {Array|null}    cellArr
	 * @return         {Object}
	 */
	this.getStylePropertyOfRangeAsBorderInfo = function(key, rowArr, cellArr){
		var value = this.getStylePropertyOfBlock(key, rowArr, cellArr),
			borderInfo = {style: &#x27;none&#x27;};
		if (value){
			value = value.trim();
			var re = new RegExp(/\s+/g);
			var arr = value.split(re);
			if (arr.length &gt;= 3){
				var width = arr.shift(),
					style = arr.shift();
				if (parseInt(width, 10) === 0){
					borderInfo.style = &#x27;none&#x27;;
				} else {
					borderInfo.style = style;
					borderInfo.width = width;
					borderInfo.color = arr.join(&#x27; &#x27;);
				}
			}
		}
		return borderInfo;
	};

	/**
	 * Creates an array of &#x60;len&#x60; increasing numbers starting with &#x60;start&#x60;:
	 * &#x60;start&#x60;, &#x60;start + 1&#x60;, ...
	 * @method         _range
	 * @param          {Number}        start
	 * @param          {Number}        len
	 * @return         {Array}
	 * @private
	 * @since          0.0.6
	 */
	var _range = function(start, len){
		var i = 0,
			output = [];
		for (i = 0; i &lt; len; i++){
			output[i] = start + i;
		}
		return output;

	};

	/**
	 * Returns an object that parametrizes borders around the cells. The object has the following format:
	 * &lt;br&gt;
	 * &lt;code&gt;
	 * {leftVer: ..., rightVer: ..., intVer: ..., topHor: ..., bottomHor: ..., intHor: ..., [width: ..., color: ...]}
	 * &lt;/code&gt;
	 * &lt;br&gt;
	 * where
	 * &lt;ul&gt;&lt;li&gt;
	 * &#x60;leftVer&#x60;, &#x60;rightVer&#x60;, &#x60;intVer&#x60;, &#x60;topHor&#x60;, &#x60;bottomHor&#x60;, &#x60;intHor&#x60; are boolean-valued keys
	 * standing for left/right/intermediate horizontal/vertical cell borders,
	 * &lt;/li&gt;&lt;li&gt;
	 * &#x60;width&#x60; - (optional) integer, present if at least one of the above boolean values is true.
	 * &lt;/li&gt;&lt;li&gt;
	 * &#x60;color&#x60; - (optional) string, present along with &quot;width&quot; key.
	 * &lt;/li&gt;&lt;/ul&gt;
	 * @method         getCellBorders
	 * @return         {Object}
	 * @since          0.0.6
	 */
	this.getCellBorders = function(){
		var output = {},
			width,
			allButFirstRow =  _range(1, this.rowNum() - 1),
			allButFirstCol =  _range(1, this.colNum() - 1),
			// set of keys necessary to get info about cell borders
			keys = {
				&#x27;topHor&#x27;:    [&#x27;border-top&#x27;, [0]],
				&#x27;bottomHor&#x27;: [&#x27;border-bottom&#x27;, [-1]],
				&#x27;intHor&#x27;:    [&#x27;border-top&#x27;, allButFirstRow],
				&#x27;leftVer&#x27;:   [&#x27;border-left&#x27;,  null, [0]],
				&#x27;rightVer&#x27;:  [&#x27;border-right&#x27;, null, [-1]],
				&#x27;intVer&#x27;:    [&#x27;border-left&#x27;,  null, allButFirstCol]
			},
			foo, borderInfo, key;

		for (key in keys){
			if (keys.hasOwnProperty(key)){
				foo = keys[key];
				borderInfo = this.getStylePropertyOfRangeAsBorderInfo(foo[0], foo[1], foo[2]);
				output[key] = borderInfo.style !== &#x27;none&#x27;;
				// if &quot;width&quot; is not initialized and the border is present,
				// set &quot;width&quot; and &quot;color&quot;
				if (width === undefined &amp;&amp; output[key]){
					width = parseInt(borderInfo.width, 10);
					output.width = width;
					output.color = borderInfo.color;
				}

			}
		}
		return output;
	};

	/**
	 * Returns {{#crossLink &quot;Properties/getBorder:method&quot;}}border-like{{/crossLink}} object characterizing
	 * {{#crossLink &quot;Table/phantomTable:property&quot;}}phantom table{{/crossLink}} (if it exists) border.
	 * If {{#crossLink &quot;Table/phantomTable:property&quot;}}phantom table{{/crossLink}} does not exist,
	 * an object &lt;code&gt;{style: none}&lt;/code&gt; is returned.
	 * @method  getPhantomTableBorder
	 * @return {Object}
	 * @since  0.0.6
	 */
	this.getPhantomTableBorder = function(){
		var output = {style: &#x27;none&#x27;},
			phTblProp = this.getPhantomTableProperties();
		if (phTblProp){
			output = phTblProp.getBorder();
		}
		return output;
	};

}
Table.prototype = Object.create(Tag.prototype);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
