<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\classes\HtmlElements\Dom.js - Newsletter API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..\images\logo.png" title="Newsletter API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.6</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CDownload.html">CDownload</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/CellProperties.html">CellProperties</a></li>
            
                <li><a href="../classes/CImage.html">CImage</a></li>
            
                <li><a href="../classes/CKEDITOR.html">CKEDITOR</a></li>
            
                <li><a href="../classes/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../classes/CLink.html">CLink</a></li>
            
                <li><a href="../classes/Content.html">Content</a></li>
            
                <li><a href="../classes/Controller.html">Controller</a></li>
            
                <li><a href="../classes/Converter.html">Converter</a></li>
            
                <li><a href="../classes/ConverterElastic.html">ConverterElastic</a></li>
            
                <li><a href="../classes/ConverterFixed.html">ConverterFixed</a></li>
            
                <li><a href="../classes/ConverterGeneral.html">ConverterGeneral</a></li>
            
                <li><a href="../classes/ConverterSimpleText.html">ConverterSimpleText</a></li>
            
                <li><a href="../classes/CTable.html">CTable</a></li>
            
                <li><a href="../classes/Document.html">Document</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/EHToolbar.html">EHToolbar</a></li>
            
                <li><a href="../classes/Factory.html">Factory</a></li>
            
                <li><a href="../classes/Helper.html">Helper</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/ImageProperties.html">ImageProperties</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/LinkDialog.html">LinkDialog</a></li>
            
                <li><a href="../classes/LinkProperties.html">LinkProperties</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListItem.html">ListItem</a></li>
            
                <li><a href="../classes/ListItemProperties.html">ListItemProperties</a></li>
            
                <li><a href="../classes/ListProperties.html">ListProperties</a></li>
            
                <li><a href="../classes/Mapper.html">Mapper</a></li>
            
                <li><a href="../classes/NEWSLETTER.html">NEWSLETTER</a></li>
            
                <li><a href="../classes/OList.html">OList</a></li>
            
                <li><a href="../classes/PlainText.html">PlainText</a></li>
            
                <li><a href="../classes/Properties.html">Properties</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/RowProperties.html">RowProperties</a></li>
            
                <li><a href="../classes/Save.html">Save</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/table2ModifyDialog.html">table2ModifyDialog</a></li>
            
                <li><a href="../classes/TableDialog.html">TableDialog</a></li>
            
                <li><a href="../classes/TableProperties.html">TableProperties</a></li>
            
                <li><a href="../classes/Tag.html">Tag</a></li>
            
                <li><a href="../classes/UList.html">UList</a></li>
            
                <li><a href="../classes/Unit.html">Unit</a></li>
            
                <li><a href="../classes/Worker.html">Worker</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CKHelper.html">CKHelper</a></li>
            
                <li><a href="../modules/Config.html">Config</a></li>
            
                <li><a href="../modules/Controllers.html">Controllers</a></li>
            
                <li><a href="../modules/Converter.html">Converter</a></li>
            
                <li><a href="../modules/Dialogs.html">Dialogs</a></li>
            
                <li><a href="../modules/Document.html">Document</a></li>
            
                <li><a href="../modules/EventHandler.html">EventHandler</a></li>
            
                <li><a href="../modules/Helper.html">Helper</a></li>
            
                <li><a href="../modules/HtmlElements.html">HtmlElements</a></li>
            
                <li><a href="../modules/Plugins.html">Plugins</a></li>
            
                <li><a href="../modules/Properties.html">Properties</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\classes\HtmlElements\Dom.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint plusplus: true, white: true */
/*global Node, Dom, Properties, Tag, Helper */

/**
 * This class deals with the elements of the editor document. Its functionality is similar
 * to those of {{#crossLink &quot;Document&quot;}}Document{{/crossLink}}.
 *
 * The difference between them: {{#crossLink &quot;Document&quot;}}Document{{/crossLink}} is a singleton,
 * while {{#crossLink &quot;Dom&quot;}}Dom{{/crossLink}} is a class that accepts creation of multiple
 * instances.
 * @module 	    Document
 * @class  		Dom
 * @constructor
 * @since       0.0.4
 * @author      A.Shcherbakov
 */

function Dom(){

	/**
	 * [CKEDITOR](http://docs.ckeditor.com/#!/api/CKEDITOR.editor) instance
	 * @property {CKEDITOR} _editor
	 * @private
	 * @since    0.0.7
	 */
	var _editor;

	/**
	 * {{#crossLink &quot;/_editor:property&quot;}}_editor{{/crossLink}} setter. {{#crossLink &quot;Dom/_editor:property&quot;}}_editor{{/crossLink}}
	 * @method setEditor
	 * @param {[type]} ed [description]
	 */
	this.setEditor = function(ed){
		_editor = ed;
	};

	/**
	 * Toggles inline style property &#x60;prop&#x60; of node &#x60;n&#x60;. When it turns out that the property should
	 * be set, it is set to value &#x60;val&#x60;.
	 *
	 * @method          _toggleNodeStyle
	 * @private
	 * @param          {DOM.Node}           n          instance of [DOM.Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)
	 * @param          {String}             prop       style property name to be toggled
	 * @param          {String}             val        on-value of the the style property
	 * @param          {String|Null}        altVal     off-value of the style property
	 * @return         {void}
	 * @since          0.0.4
	 */
	var _toggleNodeStyle = function(n, prop, val, altVal){
	    var attrName = &#x27;style&#x27;,
	        stl, stlStr;
	    if (!(typeof n === &#x27;object&#x27; &amp;&amp; n.nodeType)){
	        return;
	    }
	    // console.log(&#x27;from parents: &#x27;, _lookUpInParents(n, prop));
	    stl = new Properties(n.getAttribute(attrName));
	    stl.setMode(1);
	    stl.toggleProperty(prop, val, altVal);
	    stlStr = stl.toString();
	    if (stlStr){
	        n.setAttribute(attrName, stlStr);
	    } else {
	        n.removeAttribute(attrName);
	    }
	};


	/**
	 * Returns **proxy** node of &#x60;n&#x60;:
	 * &lt;ol&gt;&lt;li&gt;
	 * if &#x60;n&#x60; is a text element without siblings, then proxy of &#x60;n&#x60; is its parent node,
	 * &lt;/li&gt;&lt;li&gt;
	 * if &#x60;n&#x60; is a text element with siblings or is a node element, then proxy of &#x60;n&#x60; is &#x60;n&#x60; itself.
	 * &lt;/li&gt;&lt;/ol&gt;
	 * @method         _proxy
	 * @param          {DOM.Node}          n          [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @return         {DOM.Node|Null}
	 */
	this.proxy = function(n){
	    if (n === undefined || n.nodeType === undefined){
	        return null;
	    }
	    if (n.nodeType === Node.ELEMENT_NODE){
	        return n;
	    }
	    return (n.nextSibling || n.previousSibling) ? n : n.parentNode;
	};

	/**
	 * Looks for a value of style property &#x60;key&#x60; of nearest ascendant of &#x60;node&#x60; in the scope of node &#x60;scope&#x60;.
	 * If the property is found, its value is returned, otherwise,  &#x60;undefined&#x60; is returned.
	 *
	 * Limit node &#x60;scope&#x60; is supposed to contain &#x60;node&#x60;. Otherwise, the search for the property
	 * is performed up to the &quot;highest&quot; parent of &#x60;node&#x60;.
	 *
	 * NB: ** optimize algorithm in such a way that DOM is parsed only once even when &#x60;scope&#x60; is set wrong. **
	 * @method         getInheritedStyleProp
	 * @param          {DOM.Node}           node      [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {DOM.Node}           scope     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             key       name of property to find among inline style of ascendants
	 * @return         {String|Number|Null}
	 * @since          0.0.4
	 */
	this.getInheritedStyleProp = function(key, node, scope){
		if (node === undefined){
			throw new Error(&quot;Starting node must be defined!&quot;);
		}
		var root, parent, stl,
			currentNode = node;
		root = scope;
		// if the scope is not defined or if it is erraneous, impose scope to be the root.
		if (root === undefined || !root.contains(node)){
			root = node;
			parent = root.parentNode;
			while (parent){
				root = parent;
				parent = root.parentNode;
			}
		}
		while (root.contains(currentNode)){
			// a node might have no &quot;getAttribute&quot; method (as text node does)
			if (typeof currentNode.getAttribute === &#x27;function&#x27;){
				stl = new Properties(currentNode.getAttribute(&#x27;style&#x27;));
				stl.setMode(1);
				if (stl.hasProperty(key)){
					return stl.getProperty(key);
				}
			}
			currentNode = currentNode.parentNode;
		}
	};


	/**
	 * Modifies inline style properties of a {{#crossLink &quot;Selection/_proxy:method&quot;}}proxy{{/crossLink}}
	 * node of deepest children of node &#x60;n&#x60; in the following way:
	 * &lt;ol&gt;&lt;li&gt;
	 * if style property &#x60;prop&#x60; of the deepest child is equal to &#x60;val&#x60;, then inline
	 * style property of its &quot;proxy&quot; node is set to be &#x60;altVal&#x60;.
	 * &lt;/li&gt;&lt;li&gt;
	 * if style property &#x60;prop&#x60; of the deepest child is not equal to &#x60;val&#x60;, then inline
	 * style property of its &quot;proxy&quot; node is set to be &#x60;val&#x60;.
	 * &lt;/li&gt;&lt;/ol&gt;
	 * @private
	 * @method         _deferToggleStyle
	 * @param          {Node}               n                  [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             prop               name of style property (i.e., &quot;width&quot; or &quot;text-decoration&quot;)
	 * @param          {String}             val                value of style property (i.e., &quot;10px&quot; or &quot;underline&quot;)
	 * @return         {void}
	 * @since          0.0.4
	 * @todo           Try to make this method shorter
	 */
	// var _deferToggleStyle = function(n, prop, val, altVal){
	//     var childNodes = n.childNodes,
	//         childNum = childNodes.length,
	//         child, span, parent, counter;
	//     switch (childNum){
	//          // node has no children
	//         case 0:
	//             if (n.nodeType === Node.ELEMENT_NODE){
	//                 _toggleNodeStyle(n, prop, val, altVal);
	//                 break;
	//             }
	//             if (n.nodeType === Node.TEXT_NODE){
	//                 console.log(&#x27;from parents: &#x27;, _lookUpInParents(n, prop));
	//                 span = new Tag();
	//                 span.setTag(&#x27;span&#x27;);
	//                 span.setStyleProperty(prop, val);
	//                 span.setContent(n.nodeValue);
	//                 parent = n.parentNode;
	//                 if (parent){
	//                     parent.replaceChild(span.toNode(), n);
	//                 }
	//                 break;
	//             }
	//             break;
	//         // node has only one child
	//         case 1:
	//             child = n.firstChild;
	//             if (child.nodeType === Node.TEXT_NODE){
	//                  _toggleNodeStyle(n, prop, val, altVal);
	//             } else {
	//                 _deferToggleStyle(child, prop, val, altVal);
	//             }
	//             break;
	//         // node has many children
	//         default:
	//             console.log(&quot;children no. : &quot;, childNum, childNodes);
	//             for (counter = 0; counter &lt; childNum; counter++){
	//                 _deferToggleStyle(childNodes[counter], prop, val, altVal);
	//             }
	//     }
	// };




	/**
	 * Gives common ancestor of nodes n1 and n2. If it does not exist, &#x60;null&#x60; is returned.
	 * @method         _commonAncestor
	 * @private
	 * @param          {DOM.Node}           n1     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {DOM.Node}           n2     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @return         {DOM.Node|Null}
	 * @since          0.0.4
	 */
	var _commonAncestor = function(n1, n2){
	    // console.log(n1, n2);
	    if (n1 === undefined || n2 === undefined){
	        // console.log(&#x27;return undefined&#x27;);
	        return;
	    }
	    if (n1.contains(n2)){
	        // console.log(&#x27;return first argument&#x27;, n1);
	        return n1;
	    }
	    if (n2.contains(n1)){
	        // console.log(&#x27;return second argument&#x27;, n2);
	        return n2;
	    }
	    var parent = n1.parentNode;
	    while (parent &amp;&amp; !(parent.contains(n2))){
	        // console.log(&#x27;inside while loop: &#x27;, parent);
	        parent = parent.parentNode;
	    }
	    // console.log(&#x27;return parent&#x27;, parent);
	    return parent;
	};

	/**
	 * Gives common ancestor of nodes n1 and n2. If it does not exist, &#x60;null&#x60; is returned.
	 * @method         commonAncestor
	 * @param          {DOM.Node}           n1     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {DOM.Node}           n2     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @return         {DOM.Node|Null}
	 */
	this.commonAncestor = function(n1, n2){
	    return _commonAncestor(n1, n2);
	};

	/**
	 * Returns common ancestor of all array elements. If an element is not a
	 * [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance, it is ignored.
	 * @method         commonAncestorSoft
	 * @return         {DOM.Node|Null}      common ancestor of the arguments
	 */
	this.commonAncestorSoft = function(elems){
	    if (!Array.isArray(elems)){
	        return null;
	    }
	    var arg = elems.filter(function(el){
	        return el &amp;&amp; el.nodeType !== undefined;
	    });
	    if (arg.length === 0){
	        return null;
	    }
	    var el = arg.shift(),
	        elTmp;
	    while (arg.length &gt; 0){
	        elTmp = arg.shift();
	        el = _commonAncestor(el, elTmp);
	    }
	    return el;
	};

	// /**
	//  * Normalize parent of elements of the array.
	//  * @method  normalizeParentOf
	//  * @param  {Array}     elems
	//  * @return {void}
	//  */
	// this.normalizeParentOf = function(elems){
	//     var el = this.commonAncestorSoft(elems);
	//     if (el){
	//         el.normalize();
	//     }
	// };


	/**
	 * Returns the nearest node from which &#x60;node&#x60; inherits inline style property &#x60;key&#x60;. If no such node exists, returns &#x60;undefined&#x60;.
	 * @method         getMentor
	 * @param          {String}             key               name of inline style property
	 * @param          {DOM.Node}           node              [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @return         {DOM.Node|undefined}                   [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 */
	this.getMentor = function(key, node){
		var currentNode = node,
			stl;
		// if the scope is not defined or if it is erraneous, impose scope to be the root.
		while (currentNode){
			// whether the current node has attributes
			if (typeof currentNode.getAttribute === &#x27;function&#x27;){
				stl = new Properties(currentNode.getAttribute(&#x27;style&#x27;));
				if (stl.hasProperty(key)){
					return currentNode;
				}
			}
			currentNode = currentNode.parentNode;
		}
	};

	/**
	 * Nails inline style property &#x60;key&#x60; of &#x60;node&#x60;:  applies style property on &quot;innocent&quot; nodes
	 * and toggles node inline property &#x60;key&#x60; between &#x60;primary&#x60; and &#x60;secondary&#x60;.
	 *
	 * If &#x60;node&#x60; has a mentor node, then:
	 * &lt;ol&gt;&lt;li&gt;
	 * assign value of inline style property &#x60;key&#x60; of the mentor to each
	 * {{#crossLink &quot;Dom/complementNodes:method&quot;}}complement node{{/crossLink}} to the path &#x60;mentor - ... - node&#x60;,
	 * &lt;/li&gt;&lt;li&gt;
	 * eliminate inline style property &#x60;key&#x60; from the mentor,
	 * &lt;/li&gt;&lt;li&gt;
	 * call {{#crossLink &quot;Dom/setStyleProperty:method&quot;}}setStyleProperty{{/crossLink}} method that takes care of
	 * setting inline style property of &#x60;node&#x60; to required value.
	 * &lt;/li&gt;&lt;/ol&gt;
	 * If &#x60;node&#x60; has no mentor node, then set its inline style property &#x60;key&#x60; to be equal to &#x60;secondary&#x60;
	 * @method         nailStyleProperty
	 * @param          {DOM.Node}           node             [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             key              name of inline style property
	 * @param          {String|Number}      primary          primary value of inline style property
	 * @param          {String|Number}      secondary        secondary value of inline style property
	 * @return         {void}
	 */
	this.nailStyleProperty = function(node, key, primary, secondary){
		var mentor = this.getMentor(key, node);
		// changing target node if there is no mentor
		if (mentor === undefined){
			this.setStyleProperty(node, key, primary);
			return;
		}
		// from now on, mentor exists.
		// It might coincide with the node (in this case, array of complement nodes is empty).
		var complNodes = this.complementNodes(mentor, node),
			len = complNodes.length,
			mentorStyle = this.getStyleProperty(mentor, key),
			i;
		// apply mentor&#x27;s style property on complement nodes
		for (i = 0; i &lt; len; i++){
			this.setStyleProperty(complNodes[i], key, mentorStyle);
		}
		// drop the property from the mentor
		this.dropStyleProperty(mentor, key);
		// impose secondary value of the style property on the target node
		this.setStyleProperty(node, key, mentorStyle === primary ? secondary : primary);
	};


	/**
	 * Returns reference to a node with inline style property &#x60;key&#x60; being set to &#x60;value&#x60;.
	 * If &#x60;node&#x60; is a [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance,
	 * then reference it itself is returned. Otherwise, it is returned a new
	 * [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance, which contains
	 * a clone of &#x60;node&#x60; and which replaces &#x60;node&#x60;.
	 * @method         setStyleProperty
	 * @param          {DOM.Node}           node     [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             key      name of inline style property to set
	 * @param          {String|Number}      value    value of the inline style property
	 * @return         {DOM.Node}                    [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)
	 */
	this.setStyleProperty = function(node, key, value){
		if (!node || !key || !value){
			throw new Error(&#x27;Node, key and value must be given!&#x27;);
		}
		var attrName = &#x27;style&#x27;,
			isElem = node.nodeType === Node.ELEMENT_NODE,
			node2 = isElem ? node : document.createElement(&#x27;span&#x27;),
			style = new Properties(node2.getAttribute(attrName));
		style.setMode(1);
		style.setProperty(key, value);
		node2.setAttribute(attrName, style.toString());
		// arrange the node if it was created as a span
		if (!isElem){
			node2.appendChild(node.cloneNode(false));
			node.parentNode.replaceChild(node2, node);
		}
		return node2;
	};

	/**
	 * Gets inline style property with name &#x60;key&#x60; of &#x60;node&#x60;. Returns &#x60;undefined&#x60; if &#x60;node&#x60;
	 * does not have inline style property &#x60;key&#x60;.
	 * @method         getStyleProperty
	 * @param          {DOM.Node}           node          [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             key           name of inline style property of &#x60;node&#x60;
	 * @return         {String|Number}
	 */
	this.getStyleProperty = function(node, key){
		if (node &amp;&amp; key &amp;&amp; typeof node.getAttribute === &#x27;function&#x27;){
			var stl = new Properties(node.getAttribute(&#x27;style&#x27;));
			if (stl.hasProperty(key)){
				return stl.getProperty(key);
			}
		}
	};


	/**
	 * Drops inline style property &#x60;key&#x60; from &#x60;node&#x60; and removes inline style attribute if
	 * it becomes empty.
	 * Returns &#x60;true&#x60; if the initially contains inline style property &#x60;key&#x60; and &#x60;false&#x60; otherwise.
	 *
	 * @method         dropStyleProperty
	 * @param          {DOM.Node}           node      [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instance
	 * @param          {String}             key       name of inline style attribute to drop
	 * @return         {Boolean}                      &#x60;true&#x60; if successefully deleted the requested property
	 *                                                 and &#x60;false&#x60; otherwise
	 */
	this.dropStyleProperty = function(node, key){
		if (!node || !key || typeof node.getAttribute !== &#x27;function&#x27;){
			return false;
		}
		var attrName = &#x27;style&#x27;;
		var stl = new Properties(node.getAttribute(attrName));
		if (!stl.hasProperty(key)){
			return false;
		}
		stl.dropProperty(key);
		if (stl.isEmpty()){
			node.removeAttribute(attrName);
		} else {
			node.setAttribute(attrName, stl.toString());
		}
		return true;
	};


	/**
	 * Toggles style property &#x60;key&#x60; of element &#x60;elem&#x60; from &#x60;primary&#x60; to &#x60;secondary&#x60;.
	 * If the element has style property &#x60;key&#x60; equal to &#x60;primary&#x60;, then it is imposed to &#x60;secondary&#x60;.
	 * Otherwise, it is imposed to &#x60;primary&#x60;.
	 *
	 * An element is considered to have style property imposed if either the element itself, or any of
	 * its parents has that value imposed.
	 *
	 * If not [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) instance is given as the first
	 * argument, then the method performs nothing. Note, that for text nodes this method is not applicable,
	 * since text nodes have no attributes.
	 * @method         toggleElementStyle
	 * @param          {DOM.Element}        elem       [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) instance
	 * @param          {String}             key        name of style property to change
	 * @param          {String|Number}      primary    primary value of the above style property
	 * @param          {String|Number}      secondary  secondary value of the style property
	 * @return         {void}
	 * @since          0.0.4
	 */
	this.toggleElementStyle = function(elem, key, primary, secondary){
		if (elem &amp;&amp; elem.nodeType === Node.ELEMENT_NODE){
			var attrName = &#x27;style&#x27;,
				stl = new Properties(elem.getAttribute(attrName)),
				styleValue = this.getInheritedStyleProp(key, elem);
			stl.setMode(1);
			stl.setProperty(key, (styleValue === primary) ? secondary :  primary);
			elem.setAttribute(attrName, stl.toString());
		}
	};

	/**
	 * Returns an [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) instance with the style
	 * property &#x60;key&#x60; equal to &#x60;secondary&#x60; if value of &#x60;key&#x60; attribute in &quot;style&quot; property  is equal to &#x60;primary&#x60;. Otherwise,
	 * &#x60;key&#x60; value will be imposed to &#x60;primary&#x60;.
	 *
	 * Created instance is a &quot;span&quot; html tag.
	 * @method         createToggledElemFromText
	 * @param          {DOM.Text}           textNode        [Text](https://developer.mozilla.org/en-US/docs/Web/API/Text)
	 *                                                      instance whose &quot;toggle&quot; copy is to be created
	 * @param          {String}             key             name of style property (i.e., &quot;text-decoration&quot;, &quot;font-style&quot;)
	 * @param          {String|Number}      primary         primary value of the style property
	 * @param          {String|Number}      secondary       secondary value
	 * @return         {DOM.Node}
	 * @since          0.0.4
	 */
	this.createToggledElemFromText = function(textNode, key, primary, secondary){
		if (textNode &amp;&amp; textNode.nodeType === Node.TEXT_NODE){
			var output = document.createElement(&#x27;span&#x27;),
				textNodeCopy = document.createTextNode(textNode.nodeValue),
				styleValue = this.getInheritedStyleProp(key, textNode),
				styleToggled = styleValue === primary ? secondary : primary;
			output.setAttribute(&#x27;style&#x27;, key + &#x27;: &#x27; + styleToggled + &#x27;;&#x27;);
			output.appendChild(textNodeCopy);
			return output;
		}
	};


	/**
	 * Returns a one-dimensional array of [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node) instances
	 * that are descendants of &#x60;startNode-...-endNode&#x60; path but do not belong to that path.
	 * If path from &#x60;startNode&#x60; to &#x60;endNode&#x60; does not exist, an error is thrown.
	 * &lt;dl&gt;
	 * &lt;dt&gt; Path A - ... - B&lt;/dt&gt;
	 * &lt;dd&gt; An ordered collection of nodes n&lt;sub&gt;i&lt;/sub&gt; from which one needs to pass through in order
	 * to arrive to node B starting from node A passing always from a node to its child.
	 * &lt;/dd&gt;
	 * &lt;dt&gt; Descendant of a path A - ... - B&lt;/dt&gt;
	 * &lt;dd&gt;
	 * 	A node C is a descendant of A - ... - B path if parent of node C belongs to A - ... - B path.
	 * &lt;/dd&gt;
	 * &lt;/dl&gt;
	 * @method         complementNodes
	 * @param          {DOM.Node}           startNode          a [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)
	 *                                                         instance from which to start the path
	 * @param          {DOM.Node}           endNode            a [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)
	 *                                                         instance at which to finish the path
	 * @return         {Array}                                 one-dimensional array of
	 *                                                         [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)
	 *                                                         instances or empty array
	 */
	this.complementNodes = function(startNode, endNode){
		if (!startNode.contains(endNode)){
			throw new Error(&quot;Start node must contain the end one!&quot;);
		}
		if (startNode.isEqualNode(endNode)){
			return [];
		}
		var children = startNode.childNodes,
			len = children.length,
			i, child,
			result = [];
		for (i = 0; i &lt; len; i++){
			child = children[i];
			if (!child.contains(endNode)){
				result.push(child);
			} else {
				result = result.concat(this.complementNodes(child, endNode));
			}
		}
		return result;
	};

	/**
	 * Replaces &#x60;propSecondary&#x60; string by &#x60;propPrimary&#x60; one in the class attribute of &#x60;elem&#x60;.
	 * If &#x60;propSecondary&#x60; does not exist, then &#x60;propPrimary&#x60; is just appended to class
	 * attributes. If class attribute does not exist, then it is created with value &#x60;propName&#x60;.
	 * @method         switchClassProperty
	 * @param          {DOM.Element}   elem
	 * @param          {String}        propPrimary
	 * @param          {String}        propSecondary
	 * @return         {void}
	 * @since          0.0.6
	 */
	this.switchClassProperty = function(elem, propPrimary, propSecondary){
		var attrName = &#x27;class&#x27;;
		var classValue = elem.getAttribute(attrName);
		if (!classValue){
			elem.setAttribute(attrName, propPrimary);
			return;
		}
		var attrValues = classValue.split(&#x27; &#x27;);
		var index = attrValues.indexOf(propSecondary);
		if (index !== -1){
			// replace secondary-switch attribute
			attrValues[index] = propPrimary;
		} else if (attrValues.indexOf(propPrimary) === -1) {
			// insert secondary-switch attribute only if it is not already present
			attrValues.push(propPrimary);
		}
		classValue = attrValues.join(&#x27; &#x27;);
		elem.setAttribute(attrName, classValue);
	};

	/**
	 * Returns a Properties instance that accumulates the highest specificity attributes and styles of
	 * node &#x60;n&#x60; within the scope &#x60;s&#x60; (included).
	 *
	 * The method parses DOM ascending from the node &#x60;n&#x60; up to node &#x60;s&#x60; (included) and accumulates only those
	 * styles/attributes that have not been set so far: that is if an attribute encouters more than once,
	 * only its first occurence gets into consideration.
	 *
	 * If node &#x60;s&#x60; is not set, then parsing is performed up to the &quot;highest&quot; root.
	 * If node &#x60;s&#x60; is set, but node &#x60;n&#x60; is not its descendant, then a
	 * {{#crossLink &quot;Properties&quot;}}Properties{{/crossLink}} instance corresponding to node &#x60;n&#x60;
	 * is returned.
	 * @method  	   getInheritedProperties
	 * @param          {DOM.Element}   n
	 * @param          {DOM.Element}   s   Optional
	 * @return         {Properties}
	 * @since          0.0.7
	 */
	this.getInheritedProperties = function(n, s){
		var p = new Properties();
		if (!n){
			return p;
		}
		p.loadNodeProperties(n);
		var naturalLimit = s === undefined;
		if (!(naturalLimit || s.contains(n))){
			return p;
		}
		var currentNode = n.parentNode,
			currentProp;
		while (currentNode &amp;&amp; (naturalLimit || s.contains(currentNode))){
			currentProp = new Properties();
			currentProp.loadNodeProperties(currentNode);
			p.suggestProperty(currentProp);
			currentNode = currentNode.parentNode;
		}
		return p;
	};


	/********************* Selection.js start *********************************************/
	&quot;use strict&quot;;
	if (!(this instanceof Selection)) {
	    return new Selection(ed);
	}

	if (ed !== undefined &amp;&amp; !(ed instanceof CKEDITOR.editor)){
	    throw new Error(&#x27;The first argument must be a CKEDITOR.editor instance!&#x27;);
	}

	/**
	* Editor instance containing the selection.
	* @property        {CKEDITOR.editor}         editor
	* @private
	*/
	var editor = ed;

	/**
	* Selected elements.
	* @property        {CKEDITOR.dom.selection}  selected
	* @private
	*/
	var selected;
	if (editor instanceof CKEDITOR.editor){
	    selected = editor.getSelection();
	}

	/**
	* Array of [range instances](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.range) corresponding to the selection.
	* @property {Array}   ranges
	* @private
	*/
	var ranges;
	if (selected instanceof CKEDITOR.dom.selection){
	    ranges = selected.getRanges();
	}

	/**
	 * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}} getter.
	 * @method         getRanges
	 * @return         {Array}          array of CKEDITOR.dom.range instances
	 */
	this.getRanges = function(){
	    return ranges;
	};

	/**
	 * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} setter. Sets as well
	 * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}}.
	 * @method         setSelected
	 * @return         {void}
	 */
	this.setSelected = function(obj){
	    if (!(obj instanceof CKEDITOR.dom.selection)){
	        throw new Error(&#x27;The argument must be a CKEDITOR.dom.selection instance!&#x27;);
	    }
	    selected = obj;
	    ranges = selected.getRanges();
	};

	/**
	 * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} getter.
	 * @method         getSelected
	 * @return         {CKEDITOR.dom.selection}
	 * @private
	 */
	this.getSelected = function(){
	    return selected;
	};


	/**
	 * {{#crossLink &quot;Selection/editor:property&quot;}}editor{{/crossLink}} getter.
	 * @method         getEditor
	 * @return         {CKEDITOR.editor}
	 */
	this.getEditor = function(){
	    return editor;
	};

	/**
	 * {{#crossLink &quot;Selection/editor:property&quot;}}editor{{/crossLink}} setter. Sets as well
	 * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} and
	 * {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}}.
	 * @method        setEditor
	 * @param         {CKEDITOR.editor}     obj
	 */
	this.setEditor = function(obj){
	    if (!(obj instanceof CKEDITOR.editor)){
	        throw new Error(&#x27;The argument must be a CKEDITOR.editor instance!&#x27;);
	    }
	    editor = obj;
	    selected = obj.getSelection();
	    ranges = (selected instanceof CKEDITOR.dom.selection) ? selected.getRanges() : null;
	};

	/**
	* If selection is empty, returns empty array. Otherwise returns two dimensional array of the form
	* &lt;pre&gt;
	* [[a&lt;sub&gt;00&lt;/sub&gt;, a&lt;sub&gt;01&lt;/sub&gt;, ...], [a&lt;sub&gt;10&lt;/sub&gt;, a&lt;sub&gt;11&lt;/sub&gt;, ...], ...].
	* &lt;/pre&gt;
	* Each inner array corresponds to the elements inside the
	* {{#crossLink &quot;Selection/ranges:property&quot;}}ranges{{/crossLink}} property of the selection.
	* Since DOM is an ***ordered*** collection of the nodes, the the above mentioned array is
	* just a collection of simply-connected sets of nodes corresponding to the selection.
	*
	* NB1: _Simply-connected_ set is a set such that there exists a path inside the set
	* connecting two arbitrary elements of the set.
	*
	* NB2: _Path_ consists of pieces connecting two neighbours (the set is ordered, so that
	* the concept of &quot;neighbour&quot; exists).
	* @method          selectedNodes
	* @param           {Selection}          sel
	* @private
	* @return          {Array}              two dimensional array of
	*                                       [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
	*                                       or empty array
	*/
	var selectedNodes = function(sel){
	    var startContainer, endContainer,
	        startOffset, endOffset,
	        rangesLocal = sel.getRanges(),
	        range, startChild, endChild, nextChild,
	        lastBlock = [],
	        firstBlock = [],
	        middleBlock = [],
	        startElem, endElem,
	        startType, endType,
	        i, rangesLen, commonAnc,
	        selNodes = [],      // container for all sel nodes
	        rangeNodes;         // container for sel nodes in current range
	    if (rangesLocal){
	        rangesLen = rangesLocal.length;
	        for (i = 0; i &lt; rangesLen; i++){
	            // console.info(&#x27;loop&#x27;, i);
	            rangeNodes = [];
	            range = rangesLocal[i];
	            if (!range.collapsed) {
	                startContainer = range.startContainer;
	                endContainer = range.endContainer;
	                startType = startContainer.type;
	                endType   = endContainer.type;
	                startOffset = range.startOffset;
	                endOffset = range.endOffset;
	                startElem = null;
	                endElem = null;
	                lastBlock = [];
	                firstBlock = [];
	                middleBlock = [];

	                if (startContainer.equals(endContainer)){
	                    // console.log(&#x27;start = end&#x27;);
	                    if (startType === CKEDITOR.NODE_TEXT){
	                        startElem = startContainer.split(startOffset).split(endOffset - startOffset).getPrevious();
	                        endElem = startElem;
	                    } else if (startType === CKEDITOR.NODE_ELEMENT){
	                        startElem = startContainer.getChild(startOffset);
	                        // endElem = startContainer.getChild(endOffset) || startElem;
	                        endElem = startElem;
	                    }
	                } else {
	                    if (endType === CKEDITOR.NODE_TEXT){
	                        endElem = endContainer.getLength() === endOffset ? endContainer : endContainer.split(endOffset).getPrevious();
	                    } else if (endType === CKEDITOR.NODE_ELEMENT){
	                        if (endOffset &gt; 0){
	                            endElem = endContainer.getChild(endOffset - 1);
	                        } else {
	                            endElem = endContainer.getParent();
	                        }
	                    }
	                    if (startType === CKEDITOR.NODE_TEXT){
	                        // Do not split the element if its length is equal to offset.
	                        // In this case, take the next sibling of the element.
	                        startElem = startContainer.getLength() === startOffset ? startContainer.getNext() : startContainer.split(startOffset);
	                        // startElem =  startContainer.split(startOffset);
	                    } else if (startType === CKEDITOR.NODE_ELEMENT){
	                        startElem = startContainer.getChild(startOffset);
	                    }

	                }
	                if (startElem === null || endElem === null){
	                    // console.log(&#x27;start elem or end elem is null: &#x27;, startElem, endElem);
	                    break;
	                }
	                // console.log(&#x27;start elem: &#x27;, startElem, &#x27;, end elem: &#x27;, endElem);
	                if (CKHelper.containsOrEqual(startElem, endElem)){
	                    rangeNodes = [startElem];
	                } else if (CKHelper.containsOrEqual(endElem, startElem)) {
	                    rangeNodes = [endElem];
	                } else {
	                    commonAnc = startElem.getCommonAncestor(endElem);
	                    startChild = CKHelper.childWithNode(commonAnc, startElem);
	                    endChild = CKHelper.childWithNode(commonAnc, endElem);

	                    firstBlock = startElem.getParent().equals(commonAnc) ? [startElem] : CKHelper[&#x27;bunch-next-siblings&#x27;](startElem, startChild);
	                    // console.log(&#x27;firstBlock: &#x27;, firstBlock);
	                    rangeNodes = rangeNodes.concat(firstBlock);
	                    // console.log(&#x27;rangeNodes after adding first block: &#x27;, rangeNodes.length, &#x27;, &#x27;, rangeNodes);
	                    nextChild = startChild.getNext();
	                    while(nextChild &amp;&amp; !nextChild.equals(endChild)){
	                        // console.log(&#x27;pushing nextChild: &#x27;, nextChild);
	                        middleBlock.push(nextChild);
	                        nextChild = nextChild.getNext();
	                    }
	                    // console.log(&#x27;middleBlock: &#x27;, middleBlock);
	                    rangeNodes = rangeNodes.concat(middleBlock);

	                    lastBlock = endElem.getParent().equals(commonAnc) ? [endElem] : CKHelper[&#x27;bunch-prev-siblings&#x27;](endElem, endChild);

	                    // console.log(&#x27;lastBlock: &#x27;, lastBlock);
	                    rangeNodes = rangeNodes.concat(lastBlock.reverse());
	                    // console.log(&#x27;rangeNodes after adding end block: &#x27;, rangeNodes.length, &#x27;, &#x27;, rangeNodes);
	                }

	            }
	            // console.log(&#x27;rangeNodes that are to be pushed into selNodes: &#x27;, rangeNodes);
	            selNodes.push(rangeNodes);
	        }


	    }
	    // selNodes.forEach(function(elem, ind){
	    //     elem.forEach(function(elem2, ind2){
	    //         console.log(ind, ind2, elem2);
	    //     });
	    // });
	    return selNodes;
	};

	/**
	 * Two-dimensional array of nodes in selection.
	 *
	 * This property was created in order to assure that private method
	 * {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} gets called
	 * just once because it seemingly modifies DOM in such
	 * a way that if one calles it multiple times, a wrong array offset is requested, hence, an
	 * error is generated.
	 * @property       {Array}      nodes
	 * @type           {Array}      array of [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
	 */
	this.nodes = selectedNodes(this);

	/**
	 * Returns text representation of the selected nodes. Remember that they are located inside a two-dimensional array.
	 *
	 * @method    toText
	 * @param     {String}    blockSeparator          string to be used as a separator between arrays
	 * @param     {String}    elemSeparator           string to be used as a separator between elements in array
	 * @return    {String}
	 */
	this.toText = function(blockSeparator, elemSeparator){
	    var total = [];
	    blockSeparator = blockSeparator || &#x27; &#x27;;
	    elemSeparator = elemSeparator || &#x27; &#x27;;
	    this.nodes.forEach(function(arr){
	        var arrayNested = [];
	        arr.forEach(function(el){
	            if (el.type === CKEDITOR.NODE_TEXT || el.type === CKEDITOR.NODE_ELEMENT){
	                arrayNested.push(el.getText());
	            }
	        });
	        total.push(arrayNested.join(elemSeparator));
	    });
	    return total.join(blockSeparator);
	};


	/**
	 * Returns the start element of selection if it exists.
	 * @method         getStartElement
	 * @return         {CKEDITOR.dom.element}
	 */
	this.getStartElement = function(){
	    var sel = this.getSelected();
	    if (sel instanceof CKEDITOR.dom.selection){
	        return sel.getStartElement();
	    }
	};

	/**
	 * Returns &#x60;true&#x60; if {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} is empty,
	 * &#x60;false&#x60; otherwise.
	 *
	 * {{#crossLink &quot;Selection/selectedNodes:method&quot;}}selectedNodes{{/crossLink}} output is considered empty
	 * if it is either empty array &#x60;[]&#x60; or an array containing empty array: &#x60;[[]]&#x60;.
	 * @method         isEmpty
	 * @return         {Boolean}
	 */
	this.isEmpty = function(){
	    var s = this.nodes;
	    // console.log(&#x27;selected nodes&#x27;  , s);
	    //    empty array []  or containing empty array [[]]
	    return s.length === 0 || (s.length === 1 &amp;&amp; s[0].length === 0);
	};


	/**
	 * Returns &#x60;true&#x60; if selected text starts inside a link, &#x60;false&#x60; otherwise.
	 * In case when the selection is empty, cursor position is considered as beginning
	 * of empty selection.
	 * @method         startsInsideLink
	 * @return         {Boolean}            whether the selection starts inside a link
	 */
	this.startsInsideLink = function(){
	    var start = this.getStartElement(),
	        parentLink = null;
	    if (start !== undefined &amp;&amp; start !== null &amp;&amp; (typeof start.getAscendant === &#x27;function&#x27;)){
	        parentLink = start.getAscendant(&#x27;a&#x27;, true);
	    }
	    return parentLink !== null;
	};


	/**
	 * Returns &#x60;true&#x60; if selection content is editable, &#x60;false&#x60; otherwise.
	 *
	 * Selection is editable if:
	 * &lt;ol&gt;
	 * &lt;li&gt;it is empty&lt;/li&gt;
	 * &lt;li&gt;it contains a single element that has type &#x60;text&#x60;&lt;/li&gt;
	 * &lt;li&gt;it contains a single element that is a link which child nodes are of type &#x60;text&#x60;&lt;/li&gt;
	 * &lt;/ol&gt;
	 * @method         isEditable
	 * @return         {Boolean}
	 */
	this.isEditable = function(){
	    var nodes = this.nodes;
	    if (!nodes){
	        // console.log(&#x27;nodes are not defined&#x27;);
	        return true;
	    }
	    var len = nodes.length;
	    // exit point if the nodes array length differs form one
	    if (len !== 1){
	        // return true if it is empty and false if it is too long
	        return len === 0;
	    }

	    // the first (and the only) block of the selection
	    var firstBlock = nodes[0];
	    len = firstBlock.length;
	    // exit point if the firstblock is empty or has more than one element
	    if (len !== 1){
	        // return true if it is empty and false if it is too long
	        return len === 0;
	    }

	    // the only element
	    var elem = firstBlock[0];
	    if (elem.type === CKEDITOR.NODE_TEXT){
	        return true;
	    }
	    if (elem.type === CKEDITOR.NODE_ELEMENT){
	        if (elem.getName() === &#x27;a&#x27;){
	            len = elem.getChildCount();
	            if (len !== 1){
	                return len === 0;
	            }
	            return elem.getChild(0).type === CKEDITOR.NODE_TEXT;
	        }
	        return false;
	    }
	    return false;

	};

	/**
	 * Removes duplicate DOM nodes form input array. Each element of the array must be an instance of
	 * [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject).
	 * @method         dropDuplicates
	 * @private
	 * @param          {Array}              $arr    one-dimensional array of
	 *                                              [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
	 *                                              objects
	 * @return         {Array}                      array of distinct
	 *                                              [CKEDITOR.dom.domObject](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject)
	 *                                              elements
	 */
	var dropDuplicates = function(arr){
	    var len = arr.length;
	    if (len === 0 || len === 1){
	        return arr;
	    }
	    if (len &gt; 1){
	        var first = arr[0],
	            output = [],
	            outputLen = 0,
	            i, j,
	            isPresent;
	        output.push(first);
	        outputLen++;

	        for (i = 1; i &lt; len; i++){
	            isPresent = false;
	            for (j = 0; j &lt; outputLen; j++){
	                if (output[j].equals(arr[i])){
	                    isPresent = true;
	                    break;
	                }
	            }
	            if (!isPresent){
	                output.push(arr[i]);
	                outputLen++;
	            }
	        }
	        return output;
	    }
	};

	/**
	 * Replaces each element in {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} by
	 * a link in which this element is located. In case the element is not located inside any link, then it
	 * is leaved without changes. The output array mimics the structure of
	 * {{#crossLink &quot;Selection/selected:property&quot;}}selected{{/crossLink}} array: it should be a two-dimensional array
	 * without duplicates.
	 * @method         absorbLink
	 * @return         {void}
	 */
	this.absorbLink = function(){
	    var input = this.nodes,
	        output = [],
	        temp, link;
	    if (this.isEmpty()){
	        // if the selection is empty and the cursor is inside a link,
	        // insert this link into nodes
	        link = this.getStartElement().getAscendant(&#x27;a&#x27;, true);
	        if (link){
	            output.push([link]);   // resulting array must be 2-dimensional with a single element
	        }
	    } else {
	        // parse elements in the selectionif it is not empty
	        input.forEach(function(block){
	            if (Array.isArray(block) &amp;&amp; block.length &gt; 0){
	                temp = [];
	                block.forEach(function(elem){
	                    link = elem.getAscendant(&#x27;a&#x27;, true);
	                    temp.push(link || elem) ;
	                });
	                output.push(dropDuplicates(temp));
	            }
	        });

	    }
	    this.nodes = output;
	};

	/**
	 * Propagate style property named &#x60;prop&#x60; with the value &#x60;val&#x60; to the last descendant of each node in the selection.
	 * Remember that the selection is in general a two-dimensional array (or one-dimensional if the selection is empty).
	 *
	 * Update: added possibility for &#x60;prop&#x60; to be an object (in this case the rest argument are ignored)
	 * with the following keys: &lt;ol&gt;&lt;li&gt;
	 * &#x60;name&#x60; - name of the style property
	 * &lt;/li&gt;&lt;li&gt;
	 * &#x60;value&#x60; - on-value of the above property
	 * &lt;/li&gt;&lt;li&gt;
	 * &#x60;altVal&#x60; - off-value of the above property
	 * &lt;/li&gt;&lt;/ol&gt;
	 *
	 * @method         switchDeepestChildStyle
	 * @param          {String|Object}        prop        name of the property to be imposed
	 * @param          {String}               val         on-value of the above property
	 * @param          {String}               altVal      off-value of the property
	 * @since          0.0.4
	 * @return         {void}
	 */
	this.switchDeepestChildStyle = function(prop, val, altVal){
	    var propName, value, altValue;
	    if (typeof prop === &#x27;object&#x27;){
	        propName = prop.name;
	        value = prop.value;
	        altValue = prop.altValue;
	    } else {
	        propName = prop;
	        value = val;
	        altValue = altVal;
	    }
	    this.nodes.forEach(function(line){
	        var dom = new Dom();
	        if (line){
	            line.forEach(function(node){
	                dom.nailStyleProperty(node.$, propName, value, altValue);
	            });
	        }
	    });
	};


	/**
	 * Returns first ancestor of {{#crossLink &quot;Selection/nodes:property&quot;}}nodes{{/crossLink}} for which &#x60;criteria&#x60; evaluates to
	 * &#x60;true&#x60;.
	 *
	 * To function &#x60;criteria&#x60; there will be given one by one elements from {{#crossLink &quot;Selection/nodes:property&quot;}}nodes{{/crossLink}}
	 * @method  findAcsendant
	 * @param  {Function} criteria [description]
	 * @return {CKEDITOR.dom.element}  [CKEDITOR.dom.element](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.element)
	 */
	this.findAscendantOfBlock = function(criteria){
	    if (this.isEmpty()){
	        return;
	    }
	    var lenExt = this.nodes.length,
	        lenInt, i, j, block, el;
	    for (i = 0; i &lt; lenExt; i++){
	        block = this.nodes[i];
	        lenInt = block.length;
	        for (j = 0; j &lt; lenInt; j++){
	            el = block[j];
	            if (criteria(el)){
	                return el;
	            }
	        }
	    }
	};
/**************** Selection.js end *************************************************/

}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
